Earlier we established that the quantilal policy can be computed in polynomial time to any given approximation (see "Proposition 5"). Now we show that an exact quantilal policy can be computed in polynomial time (in particular there is always a rational quantilal policy). We assume geometric time discount throughout. Lemma Consider ξ ∈ Δ S . Define the linear operators E : R S × A → R S and T : R S × A → R S by E t , s a : = [ [ t = s ] ] T t , s a : = T ( t | s , a ) (Note that this T is the transpose of the T defined in "Proposition A.3" of the previous essay.) Then, ξ ∈ Im Z if and only if there is ϕ ∈ Δ ( S × A ) s.t. E ϕ = ξ ( E − λ T ) ϕ = ( 1 − λ ) ζ 0 Proof (This is actually well known, but we spell out the proof to be self-contained.) Suppose that ξ ∈ Im Z . We already know that this implies that there is a stationary policy π : S k → A s.t. Z π = ξ (we abuse notation in the obvious way): see the proofs of "Proposition 2" and "Proposition 3". Define the linear operator T π : R S → R S by T π t s : = E a ∼ π ( s ) [ T ( t | s , a ) ] It follows that ξ = ( 1 − λ ) ∞ ∑ n = 0 λ n T π n ζ 0 = ( 1 − λ ) ( 1 − λ T π ) − 1 ζ 0 ( 1 − λ T π ) ξ = ( 1 − λ ) ζ 0 Define ϕ by ϕ ( s , a ) : = ξ ( s ) π ( a ∣ s ) We have T π ξ = ∑ s ∈ S E a ∼ π ( s ) [ T ( s , a ) ] ξ ( s ) = ∑ s ∈ S a ∈ A π ( a ∣ s ) T ( s , a ) ξ ( s ) = ∑ s ∈ S a ∈ A T ( s , a ) ϕ ( s , a ) = T ϕ Also, obviously E ϕ = ξ . We get ( E − λ T ) ϕ = ξ − λ T π ξ = ( 1 − λ T π ) ξ = ( 1 − λ ) ζ 0 Conversely, suppose that ϕ is as above. Since E ϕ = ξ , there is π : S k → A s.t. for any s ∈ S , if ξ ( s ) ≠ 0 then π ( a ∣ s ) = ϕ ( s , a ) ξ ( s ) Again, we have Z π = ( 1 − λ ) ( 1 − λ T π ) − 1 ζ 0 Also, for the same reason as before ( E − λ T ) ϕ = ( 1 − λ T π ) ξ By the assumption, the left hand side equals ( 1 − λ ) ζ 0 . We conclude ξ = ( 1 − λ ) ( 1 − λ T π ) − 1 ζ 0 = Z π Theorem Assuming all parameters are rational like before, there is a polynomial time algorithm that computes a quantilal policy. Proof The algorithm starts by solving the following linear program. The indeterminates are ϕ ∈ R S × A and QV ∈ R . The goal is maximizing QV . The constraints are ∀ s ∈ S , a ∈ A : ϕ ( s , a ) ≥ 0 ∑ s ∈ S a ∈ A ϕ ( s , a ) = 1 ( E − λ T ) ϕ = ( 1 − λ ) ζ 0 ∀ s ∈ S ∖ supp Z σ , a ∈ A : ϕ ( s , a ) = 0 ∀ s ∈ supp Z σ : QV ≤ ∑ t ∈ S R ( t ) ∑ a ∈ A ϕ ( t , a ) − η Z σ ( s ) ∑ a ∈ A ϕ ( s , a ) Then, the algorithm computes π : S k → A s.t. for any s ∈ S , if ∑ b ∈ A ϕ ( s , b ) > 0 then π ( a ∣ s ) : = ϕ ( s , a ) ∑ b ∈ A ϕ ( s , b ) For s ∈ S s.t. ∑ b ∈ A ϕ ( s , b ) = 0 , π ( s ) is arbitrary. Now we need to explain why this algorithm is correct. Observe that, the first 3 constraints mean that ξ ∈ R S defined by ξ ( s ) : = ∑ b ∈ A ϕ ( s , b ) lies in Im Z (by Lemma 1) and, moreover, ϕ ( s , a ) = ξ ( s ) π ( a ∣ s ) for π : S k → A s.t. ξ = Z π . It remains to show that the linear program amounts to maximizing E ξ [ R ] − η exp D ∞ ( ξ | | Z σ ) inside Im Z . Indeed, the 4th constraint just means that D ∞ ( ξ | | Z σ ) < ∞ . The last constraint implies that we are actually maximizing min s ∈ supp Z σ ( E ξ [ R ] − η Z σ ( s ) ξ ( s ) ) The latter is indeed E ξ [ R ] − η exp D ∞ ( ξ | | Z σ ) , since every s ∈ supp Z σ corresponds to a pure strategy of the adversary in the corresponding zero-sum game: namely, this strategy is setting the penalty function P : S → [ 0 , ∞ ) to P ( t ) = [ [ t = s ] ] Z σ ( s ) (Strategies that place non-vanishing penalty on states outside of supp Z σ become irrelevant after imposing the 4th constraint. The remaining penalty functions form a simplex with vertices as above.)