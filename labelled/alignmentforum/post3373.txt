I am confused about how gradient descent (and other forms of local search) interact with Goodhart's law. I often use a simple proxy of "sample points until I get one with a large U value" or "sample n points, and take the one with the largest U value" when I think about what it means to optimize something for U . I might even say something like " n bits of optimization" to refer to sampling 2 n points. I think this is not a very good proxy for what most forms of optimization look like, and this question is trying to get at understanding the difference. (Alternatively, maybe sampling is a good proxy for many forms of optimization, and this question will help us understand why, so we can think about converting an arbitrary optimization process into a certain number of bits of optimization, and comparing different forms of optimization directly.) One reason I care about this is that I am concerned about approaches to AI safety that involve modeling humans to try to learn human value. One reason for this concern is that I think it would be nice to be able to save human approval as a test set. Consider the following two procedures: A) Use some fancy AI system to create a rocket design, optimizing according to some specifications that we write down, and then sample rocket designs output by this system until you find one that a human approves of. B) Generate a very accurate model of a human. Use some fancy AI system to create a rocket design, optimizing simultaneously according to some specifications that we write down and approval according to the accurate human model. Then sample rocket designs output by this system until you find one that a human approves of. I am more concerned about the second procedure, because I am worried that the fancy AI system might use a method of optimizing for human approval that Goodharts away the connection between human approval and human value. (In addition to the more benign failure mode of Goodharting away the connection between true human approval and the approval of the accurate model.) It is possible that I am wrong about this, and I am failing to see just how unsafe procedure A is, because I am failing to imagine the vast number of rocket designs one would have to sample before finding one that is approved, but I think maybe procedure B is actually worse (or worse in some ways). My intuition here is saying something like: "Human approval is a good proxy for human value when sampling (even large numbers of) inputs/plans, but a bad proxy for human value when choosing inputs/plans that were optimized via local search. Local search will find ways to hack the human approval while having little effect on the true value." The existence of adversarial examples for many systems makes me feel especially worried. I might find the answer to this question valuable in thinking about how comfortable I am with superhuman human modeling. Another reason why I am curious about this is that I think maybe understanding how different forms of optimization interact with Goodhart can help me develop a suitable replacement for "sample points until I get one with a large U value" when trying to do high level reasoning about what optimization will look like. Further this replacement might suggest a way to measure how much optimization happened in a system. Here is a proposed experiment, (or class of experiments), for investigating how gradient descent interacts with Goodhart's law. You might want to preregister predictions on how experiments of this form might go before reading comments. Proposed Experiment: 1. Generate a true function V : R n → R . (For example, you can write down a function explicitly, or generate a random function by randomly initializing a neural net, or training a neural net on random data) 2. Generate a proxy function U : R n → R , which can be interepereted as a proxy for V . (For example, you can generate a random noise function W , and let U = V + W , or you can train a neural net to try to copy V ) 3. Fix some initial distribution μ on R n , which will represent random sampling. (For example the normal distribution) 4. Define from μ some other distribution ^ μ , which can be interpreted as sampling points according to μ , then performing some kind of local optimization according to U . (For example, take a point x according to μ , then perform k steps of gradient ascent on U , or take a point x according to μ , sample k more points all within distance ε of x , and take the one with the highest U value) 5. Screen off the proxy value by conditioning points sampled from μ and ^ μ to be in a narrow high band of proxy values, and compare the corresponding distribution on true values. (For example, is E ( V ( x ) | U ( x ) ∈ ( y , y + ε ) ) greater when x is sampled from μ or ^ μ ?) So, after conditioning on having a high proxy value, μ represents getting that high proxy value via sampling randomly until you find one, while ^ μ represents a combination of random sampling with some form of local search. If μ does better according to the true value, this would imply that the optimization via gradient descent respects the true value less than random sampling. There are many degrees of freedom in the procedure I describe above, and even more degrees of freedom in the space of procedures that do not exactly fit the description above, but still get at the general question. I expect the answer will depend heavily on how these choices are made. The real goal is not to get a binary answer, but to develop an understanding of how (and why) the various choices effect how much better or worse local search Goodharts relative to random sampling. I am asking this question because I want to know the answer, but (maybe due the the experimental nature) it also seems relatively approachable as far as AI safety question go, so some people might want to try to do these experiments themselves, or try to figure out how they could get an answer that would satisfy them. Also, note that the above procedure is implying a very experimental way of approaching the question, which I think is partially appropriate, but it may be better to think about the problem in theory or in some combination of theory and experiments. (Thanks to many people I talked with about ideas in this post over the last month: Abram Demski, Sam Eisenstat, Tsvi Benson-Tilsen, Nate Sores, Evan Hubinger, Peter Schmidt-Nielsen, Dylan Hadfield-Menell, David Krueger, Ramana Kumar, Smitha Milli, Andrew Critch, and many other people that I probably forgot to mention.)