Scott describes two obstacles for logical inductor decision theory : reasoning sanely about untaken actions, and getting a working notion of logical updatelessness. Here, I consider the question: if we could solve the first problem, could we solve the second? I provide a somewhat plausible substitute for updatelessness which relies on taking a logical counterfactual. Motivation Suppose we have a notion of logical counterfactual, □ → , represented by a hypothetical axiomatic system L C which is also rich enough to talk about computations. We trust L C ; specifically, if it is a theorem of L C that an agent would have achieved a particular utility had it followed an alternative strategy, we put as much or more faith in this than our own intuition about what could have been. The 5-and-10 problem is solved by decree: if an agent reasoning with L C thinks taking the $10 would be worse, then thinks so because it's true. I take it that this does not solve problems which involve updateless-like reasoning about logical uncertainty. In counterfactual mugging with a logical coin , the agent can see that counterfactually giving Omega $100 doesn't get it anything in the real mathematical universe; it doesn't seem like the correct hypothetical would be anything like "If I give Omega $100 having seen that the 1000th digit of pi is even, then the digit might turn out to be odd rather than even, so I might get $10000.". This is the realm of updateless reasoning rather than counterfactuals; but, we have no satisfactory account of logical updatelessness. So, we can't directly say that it would be better to give Omega $100. However, in a sequence of scenarios using consecutive digits of pi, we can see that the strategy which always gives the $100 when Omega asks for it will do better in the average case than the strategy which refuses; half the time, we get $10K, if we're the sort of person who gives up $100 the other half of the time. Average DT I'll represent a decision problem U as a computation which takes no arguments and yields a rational number; The evaluation of U will be written Eval [ U ] . A sequence of decision problems, U n , can be defined by a function from natural numbers to computations. The average utility up to n is ¯ U n = 1 n ∑ n i = 1 Eval [ U i ] . An agent A ( n ) will be a function of n . We'll also consider the utility ¯ U B n which might have been achieved had agent A acted like agent B , which is the value u such that A : = B □ → ¯ U n = u . ( : = is supposed to be a directional assignment from the language of L C , which says that A ( n ) outputs what B ( n ) normally would for all n . Hopefully L C can define such a concept.) I make the assumption that ¯ U B n is computable. Definition: Average DT. Take a sequence of decision problems U n , an accuracy ϵ > 0 , and a finite set of alternative strategies B m ( n ) . The average-DT agent A ( n ) computes the strategy which A ( n − 1 ) selected; call it B x . It then computes ¯ U B m n − 1 for all B m . If ¯ U B y n − 1 > ¯ U B x n − 1 + ϵ for any B y , then A ( n ) selects B y to determine the output of this round; A ( n ) = B y ( n ) . Otherwise, A ( n ) = B x ( n ) . The idea is that a good way to achieve high utility for large n is to choose outputs according to the strategy which does best on average in the limit. We can eventually do that if we keep switching to whatever strategy currently does best on average (but with ϵ "stickiness" to prevent us from oscillating strategies forever). This only works under some conditions, though. Definition: Independent. A sequence of decision problems U n is independent if m ≠ n implies U n = u → ( A ( m ) : = a □ → U n = u ) . That is, hypothetically changing the output of the agent on m has no effect on the utility at n . Definition: Tail-dependent. Call a pair of strategies B , C convergent if there exists an n such that for all m > n , B ( m ) = C ( m ) . A sequence of decision problems U n is tail-dependent if, for a convergent pair B , C , if lim n → ∞ ¯ U B n exists, then lim n → ∞ ¯ U C n also exists, and lim n → ∞ ¯ U B n = lim n → ∞ ¯ U C n . Tail-dependence is a more general condition than independence. Whereas independence says that results at n only depend on actions at n , tail-dependence allows Eval [ U n ] to depend on A ( n − 1 ) , A ( n − 2 ) , and so on, as long as the effects of any initial mistakes can eventually be washed out by following an optimal strategy in the limit. Independence is only defined here because I think of it as the more typical case. The subscript n does not represent time; each instance is thought of as a decision problem of its own, and the aggregation of the utility which average-DT does is only in service of getting high utility on individual instances. If there is some dependence between instances, it is to be thought of as interaction with a separate version of oneself. Theorem. For an average-decision-theory agent A , if U n is tail-dependent, and the limits lim n → ∞ ¯ U B m n exist for all B m in the set of strategies, then the limit lim n → ∞ ¯ U A n exists, and furthermore lim n → ∞ ¯ U A n ≥ lim n → ∞ ¯ U B m n − ϵ for all B m . Proof. In the tail-dependent case, since the limits of the ¯ U B m n exist, eventually ¯ U B m n will vary by less than ϵ / 2 for all m . At that point, the agent will never switch strategies again, because the running average for the strategy currently in use, B x , will never fall more than ϵ below the running average for any other. This means A is convergent with B x . Since lim n → ∞ ¯ U B x n exists, lim n → ∞ ¯ U A n does as well, and the two are equal. □ (If we knew that only one of the B m is optimal, we could allow ϵ = 0 , since the ordering of the running-average utility of strategies can only oscillate forever when the limits are the same.) Note that the definition of $A(n) computes ¯ U B m n − 1 rather than ¯ U B m n . This was because, at least in the independent case, ¯ U n will typically  involve A ( n ) itself; it seems potentially unrealistic to assume that this case can be computed by A ( n ) (although the fact that we're only evaluating it under the hypothetical case that we act like B m may make this feasible). It also costs us nothing, in terms of the optimality guarantee. However, it may be that even U n − 1 is too intractable for A ( n ) to realistically evaluate. We can solve this in theory by using logical induction to approximate ¯ U B m n for policy selection. No matter how slowly the ¯ U B m n become computable, lim n → ∞ ¯ U B m n = lim n → ∞ E n [ ¯ U B m n ] , and the same optimality proof applies. Discussion This is very similar in flavor to asymptotic decision theory . I'll use the abbreviations AsDT and AvDT. Like AsDT, AvDT has an ϵ accuracy parameter,has a finite set of strategies which we choose from, treats the method of taking counterfactuals as given, deals with infinite sequences of decisions, and cares only about properties in the limit. Unlike AsDT, I choose the highest average reward over all rounds so far rather than the highest expected reward on this round. AsDT is also an epsilon-exploration approach, whereas AvDT relies on □ → to give the correct expected utility alternate actions would have yielded. These differences make AvDT behave in a more updateless manner than AsDT. In counterfactual mugging with a logical coin, AsDT always uses a logical inductor's best-estimate of the utility it would get right now , so it sees the coin as already determined, and sees no benefit from giving Omega money in the cases where Omega asks for money. AvDT uses logical induction (or simple evaluation) to determine the average utility which a policy gets, so it sees giving Omega money as beneficial. I doubt that an approach to learning □ → analogous to AsDT's optimistic learning of counterfactuals will work very well here, but that is mostly because I don't think it works very well for AsDT in the first place. (It does not learn the counterfactual structure we would like it to when it plays prisoner's dilemma against a copy of itself, for example.) A big limitation of this approach is the need to represent decision problems as part of some infinite sequence. Different infinite sequences will yield different 'optimal' approaches for the same decision problem. For example, AvDT's strategy for counterfactual mugging would be much different if U n were the subsequence of cases where the digit of pi is even. On the one hand, this is like saying that Omega only goes through the whole procedure in cases where it will make Omega money. But on the other hand, we're facing the exact same situation in the world -- it's just the representation as part of a sequence of problems which has changed. It seems the sequence U n plays a role similar to the prior in UDT, telling us what spread of possibilities to prepare for. Perhaps there are some conditions under which we can guarantee good asymptotic behavior for not only one sequence of decision problems, but many. If none of the sequences are subsequences of each other, then it seems possible to guarantee eventual optimality for all of them. However, that's a very limiting condition, as illustrated by the counterfactual mugging example in the previous paragraph; we need to know which sequence to pick when one is a subsequence of the other. But my uneasiness here may mainly be due to the fact that I am accustomed to an agent requiring an arbitrary prior, but unaccustomed to an agent requiring an arbitrary problem sequence. As with the problem of selecting a prior, it seems a good rule of thumb will be to pick the broader one, in absence of contrary information. I'm not holding my breath for a good notion of "universal problem sequence" here, but it would be nice if there could be such a concept. The desirability of the approach will also depend on whether the dependence on ϵ and the restriction to finite sets of strategies can be eliminated. I'm skeptical it will be possible to get rid of either one. Oh, and another problem: the behavior breaks down quickly outside the optimality conditions. If decision of even one early instance A ( n ) matters forever, the agent will ignore this in its choices. This seems problematic. Despite all these issues, my current intuition is that this approach has "the right flavor" in some sense: an optimality condition showing that we converge to the best strategy in the limit seems about as good a property as we can hope for in a decision theory compatible with logical uncertainty.