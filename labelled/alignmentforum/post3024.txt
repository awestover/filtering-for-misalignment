Epistemic status: I expect some people to say "this is obvious and trivial", and others to say "this makes no sense at all". One fundamental difference between E.T. Jaynes’ probability textbook and most others is the emphasis on including our model in the prior information. When we write an expression like P [ X = 2 | Y = 3 ] , that’s really shorthand for P [ X = 2 | Y = 3 , M ] , where M is some probabilistic model in which X and Y appear. In practice, I’ve found this useful for two main use-cases: model comparison , and interventions/counterfactuals in causal models. This post is mainly about the latter. The general idea is that an intervention in a causal model (e.g. d o ( Z = 1 ) ) takes in one model and returns a new model - it should really be written as M ′ = d o ( Z = 1 , M ) . When we write something like P [ X = 2 | Y = 3 , d o ( Z = 1 ) ] , that’s really shorthand for P [ X = 2 | Y = 3 , d o ( Z = 1 , M ) ] . In order to make this all less hand-wavy, we need to make the model M a bit more explicit. What’s in a Model? The simplest way to represent a probabilistic model is as a table of possibilities - more explicitly, a list of exhaustive and mutually-exclusive logic statements. If I roll a standard die and call the outcome X , then I’d explicitly represent my model as M = ( P [ X = 1 | M ] = 1 6 ) & … & ( P [ X = 6 | M ] = 1 6 ) . In Probability as Minimal Map , we saw that P [ X | P [ X | Y ] = p ] = p . Interpretation: I obtain some data Y , calculate the probability P [ X | Y ] = p , then my computer crashes and I lose the data. But as long as I still know p , I should still assign the same probability to X . Thus: the probability of X , given P [ X | Y ] = p (but not given Y itself!) is just p . (Note that I left the model M implicit in the previous paragraph - really we should write P [ X | P [ X | Y , M ] = p , M ] = p .) Now let’s apply that idea to the expression P [ X = 1 | M ] , with our die-model M = ( P [ X = 1 | M ] = 1 6 ) & … & ( P [ X = 6 | M ] = 1 6 ) . Our given information includes P [ X = 1 | M ] = 1 6 , so P [ X = 1 | M ] = P [ X = 1 | P [ X = 1 | M ] = 1 6 , M ] = 1 6 . Representing models this way gives a much stronger logic-flavor to the calculations; our probability calculations are a derivation in an explicit logic. The axioms of that logic are the contents of M , along with the universal laws of probability (i.e. Bayes’ rule, sum rule, etc) and arithmetic. Causality & Interventions In the case of a causal model, M would look something like M = ( G = ( . . . g r a p h . . . ) ) & ( P [ X 1 | X p a ( 1 , G ) , M ] = f 1 ( X 1 , X p a ( 1 , G ) ) ) & … & ( P [ X n | X p a ( n , G ) , M ] = f n ( X n , X p a ( n , G ) ) ) i.e. M gives a graph G and an expression for the probability of each X i in terms of i ’s parents in G . (This would be for a Bayes net; structural equations are left as an exercise to the reader.) A d o ( ) operation then works exactly like you’d expect: d o ( X i = 1 , M ) returns a new model M ′ in which: The arrows into node i in G have been removed f i has been replaced with the indicator function I [ X i = 1 ] (or, for continuous X i , δ ( X i − 1 ) d X i ) Counterfactuals work the same way, except they’re limited to structural models - i.e. every nondeterministic node must be a root. As long as the model satisfies that constraint, a counterfactual is exactly the same as an intervention: if we have some data ( X 1 , . . . , X n ) = ( 2 , 1 , . . . , − 0.3 , 6 ) , then to run the counterfactual X 3 = 1 , we calculate P [ X | ( X 1 , X 2 , X 4 , . . . , X n ) = ( 2 , 1 , . . . , − 0.3 , 6 ) , d o ( X 3 = 1 , M ) ] . If we do this with a non-structural model - i.e. if some nondeterministic node has parents - then we’ll find that the result is sometimes undefined: our axioms do not fully determine the probability in question. Why Does This Matter? Hopefully this all seems pretty trivial. Why belabor it? There are a handful of practical applications where explicitly including the model is useful. The most important of these is model comparison, especially the Bayesian approach to learning causal structure. Another application is scenarios involving a mix of different experimental interventions and observational studies. But the main reason I’m bringing it up is that agenty things have the type signature (A -> B) -> A . In English: agenty things have some model (A -> B) which predicts the results (B) of their own actions (A). They use that model to decide what actions to perform: (A -> B) -> A. In the context of causal models, the model (A -> B) is our causal model M . (A -> B) -> A means performing some computation on M in order to find A - which is a lot simpler with an explicit representation of M . Of course, we could just use the usual structural equation representation without explicitly making everything a statement in some logic - but then we’d have a lot more different types of things floating around. By explicitly making everything logic statements, we unify the formulation. Statements like “counterfactuals are underdefined for Bayes nets” become statements about provability within our logic, and can themselves be proven. Also, by formulating the model in terms of logic statements, we have a single unified language for probability queries P [ X | Y ] - the models M , M ′ , etc can be represented and manipulated in the same format as any other information.