In my previous p o s t I talked about read-eval-print loops as providing a type signature for agents. I will now explain how you can quickly transition from this framework to an ELK solution. Notation is imported from that post. Imagine we have two agents, a human and a strong AI, denoted H and M respectively. They both interact with the environment in lockstep, according to the following diagram. We have the human's utility function U H : S H → Q , which is defined on the human's model of reality. We would like to lift U H to a version U M : S M → Q that the machine can use to influence the world in way that is agreeable to the human, which we can do by learning a mapping F : S M → S H and deriving U M = F ∘ U H . But we haven't yet said what properties we want the ontology map F to have. I want to call two concepts s h and s m equal if they act the same with respect to transformation: ∀ f. f( s h ) = f( s m ) → s h = s m . The issue is that since the concepts have different types we cannot feed them as arguments to the same function. So instead let's say that ∀ s:S, E v a l H ( s h , R e a d H (s)) = E v a l M ( s m , R e a d M (s)) → s h = s m . But now we are back to the same problem where we are trying to compare concepts in two different ontologies. But this does give us a kind of inductive step where we can transfer evidence of equality between concept pairs ( s h , s m ) and ( s h ', s m '). I also believe that this kind of a coherence argument is the best we can do, since we are not allowed to peer into the semantic content of particular machine or human states when constructing the ontology map. Consider the following two graphs. My intuition is that even if I don't know the labels of the above graphs, I can still infer that the bottom nodes correspond to each other. And the arrows that I get in the context of ELK are the agents' Eval transitions, leading to the following commutative diagram specification for F. We can learn an ontology map F : S M → S H by minimizing the difference between two paths from a state s m , one in which the machine's prediction function is used and one in which the human's prediction function is used.  Concretely, I propose minimizing Dist( s h 1 , s h 2 ) + λ |U( s h 1 )-U( s h 2 )| where s h 1 = F( E v a l M ( s m , o m )) and s h 2 = E v a l H (F( s m ), o h ), Dist is a distance metric in S H , and observations o m and o h are generated by the same underlying state S. If you are interested in getting more detail and why I believe this circumvents existing counterexamples, please check out the full p r o p o s a l .