A putative new idea for AI control; index here . A reflectively consistent agent is one that is ok with creating copies with the same motivation as itself, or continuing to have the same motivation under self-modification. A reflectively stable agent is one that would only create agents with the same motivation as itself (unless rewarded for doing otherwise), and would actively want to preserve its motivation under self-modification. Here is a design that is reflectively stable for its own self-modification, but not even reflectively consistent for copies and subagents. Subtracting the value function Let h t be the history of the agent's interaction with the environment up to time t . Let the agent A have policy π A . Let V ( R , π , h t ) be the expected value of (future) reward R under policy π , given history h t . Let π R the policy that maximises this value the most. Initially, the agent has no reward. Then, at time t , the AI gets reward function R , and gets the penalty: − c V ( R , π A , h t ) . For c < 1 , this change of reward is reflexively stable (the agent will choose π A = π R to get maximal expected reward ( 1 − c ) V ( R , π R , h t ) ), for c = 1 , it is reflexively consistent (any policy π A gives the same expected reward of 0 ), and for c > 1 , it is neither. But instead, imagine the agent gets the penalty: − c V ( R , π R , h t ) . In this case, the agent is reflexively stable for all values of c ! That's because the penalty term is independent of its policy choice, and it will therefore choose π A = π R after t to maximise the reward it does get from R . No subagent stability. Using π R in the reward may make the agent itself reflexively stable, but if c > 1 , it will not copy the same goal into its subagent. This is easy to see, because the agent's expected reward is ( 1 − c ) V ( R , π R , h t ) , so its best policy is to minimise V ( R , π R , h t ) . It will do this by acting so that h t is one the minimises that values. For instance, it might create subagents whose task is to actively restrain the agent after t . Then it will struggle against them after t (because it now wants to maximise the reward R ), but will set them up to be as powerful as possible before that, because before t , it wants its own future struggles to fail. Clearly, though this is technically reflectively stable, this is not a good sort of stability. Not 'real' stability It should be noted that the agent's "stability" is an artefact of the fact that π R is defined to be "the best policy that the agent can follow to maximise R ". "The agent" is not an ontologically fundamental object, so this stability is only as good as our definition of the agent (just as we could make the whole setup subagent-stable, if only we could define subagents - which we can't really do ).