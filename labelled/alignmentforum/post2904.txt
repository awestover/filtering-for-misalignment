This is the seventh post in the Cartesian frames sequence. Here, we introduce three new binary operations on Cartesian frames, and discuss their properties. 1. Tensor Our first multiplicative operation is the tensor product, ⊗ . One way we can visualize our additive operations from before, ⊕ and & , is to imagine two robots (say, a mining robot Agent ( C ) and a drilling robot Agent ( D ) ) that have an override mode allowing an AI supervisor to take over that robot's decisions. C ⊕ D represents the supervisor deciding which robot to take control of, then selecting that robot's action. (The other robot continues to run autonomously.) C & D represents something in the supervisor's environment (e.g., its human operator) deciding which robot the supervisor will take control of. Then the supervisor selects that robot's action (while the other robot runs autonomously). C ⊗ D represents an AI supervisor that controls both robots simultaneously. This lets Agent ( C ⊗ D ) direct Agent ( C ) and Agent ( D ) to work together as a team. Definition: Let C = ( A , E , ⋅ ) and D = ( B , F , ⋆ ) be Cartesian frames over W . The tensor product of C and D , written C ⊗ D , is given by C ⊗ D = ( A × B , hom ( C , D ∗ ) , ⋄ ) , where hom ( C , D ∗ ) is the set of morphisms ( g , h ) : C → D ∗ (i.e., the set of all pairs ( g : A → F , h : B → E ) such that b ⋆ g ( a ) = a ⋅ h ( b ) for all a ∈ A , b ∈ B ), and ⋄ is given by ( a , b ) ⋄ ( g , h ) = b ⋆ g ( a ) = a ⋅ h ( b ) . Let us meditate for a moment on why this definition represents two agents working together on a team. The following will be very informal. Let Alice be an agent with Cartesian frame C = ( A , E , ⋅ ) , and let Bob be an agent with Cartesian frame D = ( B , F , ⋆ ) . The team consisting of Alice and Bob should have agent A × B , since the team's choices consist of deciding what Alice does and also deciding what Bob does. The environment is a bit more complicated. Starting from Alice, to construct the team, we want to internalize Bob's choices: instead of just being choices in A 's environment, Bob's choices will now be additional options for the team A × B . To do this, we want to first see Bob as being embedded in Alice's environment. This embedding is given by a function h : B → E , which extends each b ∈ B to a full environment e ∈ E . We will view Alice's possible environments as being constructed by combining a choice by Bob (that is, a b ∈ B ) with a function from Bob's choices to possible environments ( h : B → E ). Then, we will move the B part across the Cartesian boundary into the agent. Now, the agent looks like A × B , while the environment looks like B → E . However, we must have been able to do this starting from Bob as well, so a possible environment can also be viewed as function g : A → F . Since we should get the same world regardless of whether we think of the team as starting with Alice or with Bob, these functions g and h should agree with each other. This looks a bit like currying. The environment for an Alice-Bob team should be able to take in a Bob to create an environment for Alice, and it should also be able to take in an Alice to create an environment for Bob. 1.1. Example We will illustrate this new operation using a simple formal example. Jack, Kate, and Luke are simultaneously casting votes on whether to have a party. Each agent can vote for or against the party. The possible worlds are encoded as strings listing which people vote for the party, W = { ε , J , K , L , JK , JL , KL , JKL } . Jack's perspective is given by the frame C J = ( J JK JL JKL ε K L KL ) , Kate's perspective is given by the frame C K = ( K JK KL JKL ε J L JL ) , and Luke's perspective is given by the frame C L = ( L JL KL JKL ε J K JK ) . Since Luke's environment can be thought of as the team consisting of Jack and Kate, one might expect that C J ⊗ C K ≅ C ∗ L . Indeed, we will show this is the case. Let C J = ( A , E , ⋅ ) , and let C K = ( B , F , ⋆ ) . We label the elements of A , E , B , and F as follows: C J = e ε e K e L e K L a J a ε ( J JK JL JKL ε K L KL ) , and C K = f ε f J f L f J L b K b ε ( K JK KL JKL ε J L JL ) . We will first enumerate all of the morphisms from C J to C ∗ K . A morphism ( g , h ) : C J → C ∗ K consists of a function g : A → F and a function h : B → E . There are 16 functions from A to F and 16 functions from B to E , but most of the 256 pairs do not form morphisms. Let us break the possibilities into cases based on g ( a J ) . Observe that b K ⋆ g ( a J ) = a J ⋅ h ( b K ) : the possible worlds where (from Kate's perspective) Kate votes for the party and Jake-interfacing-with-Kate's-perspective votes for the party too, are the same as the possible worlds where (from Jake's perspective) Jake votes for the party and Kate-interfacing-with-Jake's-perspective does too. These possible worlds must have a J in them, so g ( a J ) must be either f J or f J L . If g ( a J ) = f J , then a J ⋅ h ( b K ) = b K ⋆ g ( a J ) = JK , so h ( b K ) = e K . Similarly, a J ⋅ h ( b ε ) = b ε ⋆ g ( a J ) = J , so h ( b ε ) = e ε , and b K ⋆ g ( a ε ) = a ε ⋅ h ( b K ) = K , so g ( a ε ) = f ε . Similarly, if g ( a J ) = f J L , then h ( b K ) = e K L , h ( b ε ) = e L , and g ( a ε ) = f L . Thus, there are only two candidate morphisms: The first, which we will call ϕ ε = ( g ε , h ε ) , is given by g ε ( a ε ) = f ε , g ε ( a J ) = f J , h ε ( b ε ) = e ε , and h ε ( b K ) = e K . The second, ϕ L = ( g L , h L ) , is given by g L ( a ε ) = f L , g L ( a J ) = f J L , h L ( b ε ) = e L , and h L ( b K ) = e K L . It is easy to see that these are both indeed morphisms, by checking the definition of morphism on all four pairs in A × B . Thus, Env ( C J ⊗ C K ) = { ϕ ε , ϕ L } , and Agent ( C J ⊗ C K ) = A × B , and we can compute Eval ( C J ⊗ C K ) from the definitions of the morphisms. The result is as follows: C J ⊗ C K = ϕ ε ϕ L ( a J , b K ) ( a J , b ε ) ( a ε , b K ) ( a ε , b ε ) ⎛ ⎜
⎜
⎜ ⎝ JK JKL J JL K KL ε L ⎞ ⎟
⎟
⎟ ⎠ . This is clearly C ∗ L , up to reordering and relabeling rows and columns. 2. Properties of Tensor Tensor introduces a lot of categorical structure to Chu spaces, in fact giving us a star-autonomous category . This post and the ones to come will be ignoring connections to larger topics in category theory, but only because my time and my familiarity with category theory are limited, not because these connections are unimportant. I encourage the interested reader to learn more about the structure of Chu spaces on the excellent category theory wiki n Lab , beginning with their article on the Chu construction . 2.1. Commutativity, Associativity, and Identity Claim: ⊗ is commutative and associative, and 1 is the identity of ⊗ (up to isomorphism). Proof: Commutativity is clear from the definition of ⊗ , once one unpacks the definition of hom ( C , D ∗ ) . To see that 1 is the identity of ⊗ , let C = ( A , E , ⋅ ) , let 1 = ( { b } , W , ⋆ ) , and let C ⊗ 1 = ( A × { b } , hom ( C , 1 ∗ ) , ⋄ ) . Consider the isomorphism ( ι 0 , ι 1 ) : C → C ⊗ 1 given by ι 0 ( a ) = ( a , b ) and ι 1 ( g , h ) = h ( b ) . We need to show that ( ι 0 , ι 1 ) is a morphism, and that both ι 0 and ι 1 are bijective. To see that ( ι 0 , ι 1 ) is a morphism, observe that for all a ∈ A and ( g , h ) : C → 1 ∗ , ι 0 ( a ) ⋄ ( g , h ) = a ⋅ h ( b ) = a ⋅ ι 1 ( g , h ) . Clearly, ι 0 is a bijection, so all that remains to show is that ι 1 is bijective. To see that ι 1 is injective, observe that if ι 1 ( g 0 , h 0 ) = ι 1 ( g 1 , h 1 ) , then h 0 ( b ) = h 1 ( b ) , so h 0 = h 1 , and g 0 ( a ) = b ⋆ g 0 ( a ) = a ⋅ h 0 ( b ) = a ⋅ h 1 ( b ) = b ⋆ g 1 ( a ) = g 1 ( a ) for all a ∈ A , so g 0 = g 1 . To see that ι 1 is surjective, observe that for every e ∈ E , there exists a morphism ( g e , h e ) : C → 1 ∗ , given by h e ( b ) = e and g e ( a ) = a ⋅ e . This is clearly a morphism, since b ⋆ g e ( a ) = g e ( a ) = a ⋅ e = a ⋅ h e ( b ) , and ι 1 ( g e , h e ) = e . Next, we need to show that ⊗ is associative, which will be much more tedious. Let C i = ( A i , E i , ⋅ ) . Since we have already established commutativity, it suffices to show that ( C 0 ⊗ C 1 ) ⊗ C 2 ≅ ( C 0 ⊗ C 2 ) ⊗ C 1 . Let D = ( A 0 × A 1 × A 2 , F , ⋆ ) , where F is the set of all triples of functions ( g 0 : A 1 × A 2 → E 0 , g 1 : A 0 × A 2 → E 1 , g 2 : A 0 × A 1 → E 2 ) , such that for all a i ∈ A i , we have a 0 ⋅ 0 g 0 ( a 1 , a 2 ) = a 1 ⋅ 1 g 1 ( a 0 , a 2 ) = a 2 ⋅ 2 g 2 ( a 0 , a 1 ) , and ⋆ is given by ( a 0 , a 1 , a 2 ) ⋆ ( g 0 , g 1 , g 2 ) = a 0 ⋅ 0 g 0 ( a 1 , a 2 ) = a 1 ⋅ 1 g 1 ( a 0 , a 2 ) = a 2 ⋅ 2 g 2 ( a 0 , a 1 ) . We will show that ( C 0 ⊗ C 1 ) ⊗ C 2 ≅ D , and since the definition of D is symmetric in swapping C 1 and C 2 , it will follow that ( C 0 ⊗ C 2 ) ⊗ C 1 ≅ D , so ( C 0 ⊗ C 1 ) ⊗ C 2 ≅ ( C 0 ⊗ C 2 ) ⊗ C 1 . We construct a morphism ( ι 0 , ι 1 ) from ( C 0 ⊗ C 1 ) ⊗ C 2 to D as follows. ι 0 is just the identity on A 0 × A 1 × A 2 . We will let ι 1 ( g 0 , g 1 , g 2 ) be the morphism ( g 2 , h ) : C 0 ⊗ C 1 → C ∗ 2 , where h : A 2 → hom ( C 0 , C ∗ 1 ) is given by h ( a 2 ) = ( h a 2 0 , h a 2 1 ) : C 0 → C ∗ 1 , where h a 2 0 ( a 0 ) = g 1 ( a 0 , a 2 ) , and h a 2 1 ( a 1 ) = g 0 ( a 1 , a 2 ) . First, we need to show that ι 1 is well-defined, by showing that h ( a 2 ) is a morphism from C 0 to C ∗ 1 , and that ( g 2 , h ) is a morphism from C 0 ⊗ C 1 → C ∗ 2 . To see that h ( a 2 ) = ( h a 2 0 , h a 2 1 ) is a morphism, observe that for a 0 ∈ A 0 and a 1 ∈ A 1 , a 1 ⋅ 1 h a 2 0 ( a 0 ) = a 1 ⋅ 1 g 1 ( a 0 , a 2 ) = a 0 ⋅ 0 g 0 ( a 1 , a 2 ) = a 0 ⋅ 0 h a 2 1 ( a 1 ) . To see that ( g 2 , h ) is a morphism, observe for all ( a 0 , a 1 ) ∈ A 0 × A 1 and all a 2 ∈ A 2 , a 2 ⋅ 2 g 2 ( a 0 , a 1 ) = a 0 ⋅ 0 g 0 ( a 1 , a 2 ) = a 0 ⋅ 0 h a 2 1 ( a 1 ) = ( a 0 , a 1 ) ⋄ ( h a 2 0 , h a 2 1 ) = ( a 0 , a 1 ) ⋄ h ( a 2 ) , where ⋄ = Eval ( C 0 ⊗ C 1 ) . Now that we know ι 1 is well-defined, we need to show that ( ι 0 , ι 1 ) is a morphism. Indeed, for all ( a 0 , a 1 , a 2 ) ∈ A 0 , A 1 , A 2 , and for all ( g 0 , g 1 , g 2 ) ∈ F , we have ι 0 ( a 0 , a 1 , a 2 ) ⋆ ( g 0 , g 1 , g 2 ) = a 2 ⋅ 2 g 2 ( a 0 , a 1 ) = ( a 0 , a 1 , a 2 ) ∙ ( g 2 , h ) = ( a 0 , a 1 , a 2 ) ∙ ι 1 ( g 0 , g 1 , g 2 ) , where ∙ = Eval ( ( C 0 ⊗ C 1 ) ⊗ C 2 ) . Finally, to show that ( ι 0 , ι 1 ) is an isomorphism, we need to show that ι 0 and ι 1 are bijective. ι 0 is trivial, since it is the identity, so it suffices to show that ι 1 is bijective. To see that ι 1 is surjective, let ( g , h ) be a morphism from C 0 ⊗ C 1 to C ∗ 2 , so g : A 0 × A 1 → E 2 , and h : A 2 → hom ( C 0 , C ∗ 1 ) . Again, let h ( a 2 ) = ( h a 2 0 , h a 2 1 ) . We will define ( g 0 , g 1 , g 2 ) by g 2 = g , g 1 ( a 0 , a 2 ) = h a 2 0 ( a 0 ) , and g 0 ( a 1 , a 2 ) = h a 2 1 ( a 1 ) . We need to show that ( g 0 , g 1 , g 2 ) ∈ F , by showing that for all ( a 0 , a 1 , a 2 ) ∈ A 0 × A 1 × A 2 , we have a 0 ⋅ 0 g 0 ( a 1 , a 2 ) = a 1 ⋅ 1 g 1 ( a 0 , a 2 ) = a 2 ⋅ 2 g 2 ( a 0 , a 1 ) . Observe that since ( g , h ) is a morphism, a 2 ⋅ 2 g 2 ( a 0 , a 1 ) = a 2 ⋅ 2 g ( a 0 , a 1 ) = ( a 0 , a 1 ) ⋆ h ( a 2 ) = ( a 0 , a 1 ) ⋆ ( h a 2 0 , h a 2 1 ) , where ⋆ = Eval ( C 0 ⊗ C 1 ) . Also, by the definition of C 0 ⊗ C 1 , we have that ( a 0 , a 1 ) ⋆ ( h a 2 0 , h a 2 1 ) = a 0 ⋅ 0 h a 2 1 ( a 1 ) = a 0 ⋅ 0 g 0 ( a 1 , a 2 ) , and similarly ( a 0 , a 1 ) ⋆ ( h a 2 0 , h a 2 1 ) = a 1 ⋅ 1 h a 2 0 ( a 1 ) = a 1 ⋅ 1 g 1 ( a 0 , a 2 ) . Thus, a 0 ⋅ 0 g 0 ( a 1 , a 2 ) = a 1 ⋅ 1 g 1 ( a 0 , a 2 ) = a 2 ⋅ 2 g 2 ( a 0 , a 1 ) , so ( g 0 , g 1 , g 2 ) ∈ F . Finally, observe that ι 1 ( g 0 , g 1 , g 2 ) is in fact ( g , h ) . To show that ι 1 is injective, assume ι 1 ( g 0 , g 1 , g 2 ) = ι 1 ( g ′ 0 , g ′ 1 , g ′ 2 ) = ( g , h ) , and given an a 2 ∈ A 2 , let h ( a 2 ) = ( h a 2 0 , h a 2 1 ) . Clearly, this means g 2 = g = g ′ 2 . Further, for all a 0 ∈ A 0 , a 1 ∈ A 1 , and a 2 ∈ A 2 , g 0 ( a 1 , a 2 ) = h a 2 1 ( a 1 ) = g ′ 0 ( a 1 , a 2 ) and g 1 ( a 0 , a 2 ) = h a 2 0 ( a 0 ) = g ′ 1 ( a 0 , a 2 ) . Thus ( g 0 , g 1 , g 2 ) = ( g ′ 0 , g ′ 1 , g ′ 2 ) . Thus, ι 1 is bijective, so ( ι 0 , ι 1 ) is an isomorphism, so ( C 0 ⊗ C 1 ) ⊗ C 2 ≅ D ≅ ( C 0 ⊗ C 2 ) ⊗ C 1 . □ 2.2. Biextensional Equivalence Since many of our intuitions about Cartesian frames are up to biextensional equivalence, we should verify that tensor is well-defined up to biextensional equivalence. Claim: If C 0 ≃ C 1 and D 0 ≃ D 1 , then C 0 ⊗ D 0 ≃ C 1 ⊗ D 1 . Proof: It suffices to show that for all D , C 0 ⊗ D ≃ C 1 ⊗ D . Then, by commutativity of tensor, C 0 ⊗ D 0 ≃ C 0 ⊗ D 1 ≅ D 1 ⊗ C 0 ≃ D 1 ⊗ C 1 ≡ C 1 ⊗ D 1 . Let C i = ( A i , E i , ⋅ i ) , and let D = ( B , F , ⋆ ) . Since C 0 ≃ C 1 , there must exist morphisms ( g 0 , h 0 ) : C 0 → C 1 and ( g 1 , h 1 ) : C 1 → C 0 such that ( g 1 ∘ g 0 , id E 0 ) : C 0 → C 0 and ( g 0 ∘ g 1 , id E 1 ) : C 1 → C 1 are both morphisms. Let C i ⊗ D = ( A i × B , hom ( C i , D ∗ ) , ⋄ i ) . Consider the morphisms ( g ′ i , h ′ i ) : C i ⊗ D → C 1 − i ⊗ D , where g ′ i : A i × B → A 1 − i × B is given by g ′ i ( a , b ) = ( g i ( a ) , b ) and h ′ i : hom ( C 1 − i , D ∗ ) → hom ( C I , D ∗ ) is given by h ′ i ( g , h ) = ( g , h ) ∘ ( g i , h i ) . To see that these are morphisms, observe that for any ( a , b ) ∈ A i × B and ( g , h ) : C 1 − i → D ∗ , we have g ′ i ( a , b ) ⋄ 1 − i ( g , h ) = ( g i ( a ) , b ) ⋄ 1 − i ( g , h ) = b ⋆ g ( g i ( a ) ) = b ⋆ ( g ∘ g i ) ( a ) ) = ( a , b ) ⋄ i ( g ∘ g i , h i ∘ h ) = ( a , b ) ⋄ i h ′ i ( g , h ) . Finally, we need to show that ( g ′ 0 , h ′ 0 ) and ( g ′ 1 , h ′ 1 ) compose to something homotopic to the identity in both orders. This is equivalent to saying that ( g ′ 0 ∘ g ′ 1 , id hom ( C 1 , D ∗ ) ) and ( g ′ 1 ∘ g ′ 0 , id hom ( C 0 , D ∗ ) ) are both morphisms. Indeed, for all ( a , b ) ∈ A i × B and ( g , h ) : C i → D ∗ , since ( g 1 − i ∘ g i , id E i ) is a morphism, we have g ′ 1 − i ( g ′ i ( a , b ) ) ⋄ i ( g , h ) = ( g 1 − i ( g i ( a ) ) , b ) ⋄ i ( g , h ) = g 1 − i ( g i ( a ) ) ⋅ i h ( b ) = a ⋅ i h ( b ) = ( a , b ) ⋄ i ( g , h ) . □ 2.3. Distributivity Claim: ⊗ distributes over ⊕ , so for all Cartesian frames C 0 , C 1 , and D , ( C 0 ⊕ C 1 ) ⊗ D ≅ ( C 0 ⊗ D ) ⊕ ( C 1 ⊗ D ) . Proof: Since ⊕ is the categorical coproduct, there exist morphisms ι 0 : C 0 → C 0 ⊕ C 1 and ι 1 : C 1 → C 0 ⊕ C 1 such that for any morphisms ϕ 0 : C 0 → D ∗ and ϕ 1 : C 1 → D ∗ , there exists a unique morphism ϕ : C 0 ⊗ C 1 → D ∗ such that ϕ i = ϕ ∘ ι i . Let C i = ( A i , E i , ⋅ i ) , and let D = ( B , F , ⋆ ) . Consider the isomorphism ( g , h ) : ( C 0 ⊗ D ) ⊕ ( C 1 ⊗ D ) → ( C 0 ⊕ C 1 ) ⊗ D , where g : ( A 0 × B ) ⊔ ( A 1 × B ) → ( A 0 ⊔ A 1 ) × B is the natural bijection that sends ( a , b ) to ( a , b ) , and h : hom ( C 0 ⊕ C 1 , D ∗ ) → hom ( C 0 , D ∗ ) × hom ( C 1 , D ∗ ) is given by h ( ϕ ) = ( ϕ ∘ ι 0 , ϕ ∘ ι 1 ) . Clearly, g is an bijection. h is also a bijection, since it is inverse to the function that sends ( ϕ 0 , ϕ 1 ) to the unique ϕ as above. Thus, all that remains to show is that ( g , h ) is a morphism. Let ⋄ = Eval ( ( C 0 ⊗ D ) ⊕ ( C 1 ⊗ D ) ) and let ∙ = Eval ( ( C 0 ⊕ C 1 ) ⊗ D ) . Given ( a , b ) ∈ ( A 0 × B ) ⊔ ( A 1 × B ) and ( g ′ , h ′ ) ∈ hom ( C 0 ⊕ C 1 , D ∗ ) , without loss of generality, assume that a ∈ A 0 . Let ( g ′ 0 , h ′ 0 ) = ( g ′ , h ′ ) ∘ ι 0 . Observe that since the function on agents in ι 0 is the inclusion of A 0 into A 0 ⊔ A 1 , we have that g ′ 0 is g ′ restricted to A 0 . Thus, we have g ( a , b ) ∙ ( g ′ , h ′ ) = ( a , b ) ∙ ( g ′ , h ′ ) = b ⋆ g ′ ( a ) = b ⋆ g ′ 0 ( a ) = ( a , b ) ⋄ ( g ′ 0 , h ′ 0 ) = ( a , b ) ⋄ h ( g ′ , h ′ ) . □ 2.4. Tensor is for Disjoint Agents It doesn't really make sense to talk about C ⊗ D when C and D 's agents are the same agent, or otherwise overlap. This is because C ⊗ D 's agent can make choices for both C and D , and if C and D overlap, C ⊗ D 's agent could make choices for the intersection in two contradictory ways. If you try to take the tensor of two frames whose agents overlap, you get a frame with an agent but no possible worlds. Claim: If Ensure ( C ) ∩ Prevent ( D ) is nonempty, then C ⊗ D ≃ ⊤ . Proof: Let C = ( A , E , ⋅ ) , and let D = ( B , F , ⋆ ) . Consider some S ∈ Ensure ( C ) ∩ Prevent ( D ) . There is some a ∈ A such that a ⋅ e ∈ S for all e ∈ E , and some b ∈ B such that b ⋆ f ∉ S for all f ∈ F . First, observe that Agent ( C ⊗ D ) is nonempty, since it contains ( a , b ) . Next, observe that Env ( C ⊗ D ) is empty, since if there were a morphism ( g , h ) : C → D ∗ , it would need to satisfy b ⋆ g ( a ) = a ⋅ h ( b ) , which is impossible since the left hand side is not in S , while the right hand side is in S . Thus, C ⊗ D has empty environment and nonempty agent, so C ⊗ D ≃ ⊤ . □ Tensoring an agent with itself lets you play "both" agents, which has the neat consequence that if the agent has any control, you can have the agent make two different choices that put you in two different possible worlds, which is a contradiction. The result is that the agent has no possible worlds. Corollary: If Ctrl(C) is nonempty, then C ⊗ C ≃ ⊤ . Proof: Trivial. □ 3. Tensor is Relative to a Coarse World Model Recall that for any function p : W → V , the functor p ∘ : Chu ( W ) → Chu ( V ) preserves sums and products, meaning that for any Cartesian frames C and D over W , p ∘ ( C ⊕ D ) = p ∘ ( C ) ⊕ p ∘ ( D ) and p ∘ ( C & D ) = p ∘ ( C ) & p ∘ ( D ) . However, the same is not true for ⊗ . To see this, let's go back to the voting example above. Let's assume that Jack, Kate, and Luke have a party if and only if a majority vote in favor, and let V = { Y , N } be the two-element world that only tracks whether or not they have a party. Let p : W → V be the function such that p ( ε ) = p ( J ) = p ( K ) = p ( L ) = N and p ( JK ) = p ( JL ) = p ( KL ) = p ( JKL ) = Y . Then, p ∘ ( C J ) ≅ p ∘ ( C K ) ≅ ( N Y Y Y N N N Y ) ≃ ( N Y Y N N Y ) , and p ∘ ( C J ⊗ C K ) ≅ p ∘ ( C ∗ L ) ≅ ⎛ ⎜
⎜
⎜ ⎝ Y Y N Y N Y N N ⎞ ⎟
⎟
⎟ ⎠ ≃ ⎛ ⎜ ⎝ Y Y N Y N N ⎞ ⎟ ⎠ , but ( N Y Y Y N N N Y ) ⊗ ( N Y Y Y N N N Y ) / ≄ ⎛ ⎜
⎜
⎜ ⎝ Y Y N Y N Y N N ⎞ ⎟
⎟
⎟ ⎠ . We can see that p ∘ ( C J ⊗ C K ) is not equivalent to p ∘ ( C J ) ⊗ p ∘ ( C K ) by observing that the latter has a constant N environment while the former doesn't. Let p ∘ ( C J ) ≅ p ∘ ( C K ) ≅ ( A , E , ⋅ ) , and let e N ∈ E denote the environment such that a ⋅ e N = N for both a ∈ A . (In the matrix representation above, this is the first column.) Observe that there exists a morphism ( g , h ) : ( A , E , ⋅ ) → ( A , E , ⋅ ) ∗ , where g and h are both the constant e N function. This is a morphism because for all a 0 , a 1 ∈ A , a 0 ⋅ h ( a 1 ) = a 1 ⋅ g ( a 0 ) = N . This gives an environment in p ∘ ( C J ) ⊗ p ∘ ( C K ) , all of whose entries must be N . p ∘ ( C J ⊗ C K ) has no such environment, so p ∘ ( C J ⊗ C K ) cannot be isomorphic to p ∘ ( C J ) ⊗ p ∘ ( C K ) , or even biextensionally equivalent. Indeed: p ∘ ( C J ) ⊗ p ∘ ( C K ) ≃ ⎛ ⎜
⎜
⎜ ⎝ N Y Y Y Y Y N N N Y Y Y N N Y N Y Y N N N N N Y ⎞ ⎟
⎟
⎟ ⎠ . To see what is going on here, consider another example where Jack and Kate and Luke vote on whether to have a party, but whether or not the party happens is not just a function of the majority's vote. Instead, after the three people cast their votes, a coin is flipped: If heads, the votes are tallied and majority wins as normal. If tails, one of the three voters is selected at random to be dictator, and the party happens if and only if they voted in favor. Let us work up to biextensional collapse. Let D J be the Cartesian frame over V representing Jack's perspective. We have D J ≃ ( N Y Y N N Y ) , where the top row represents voting for the party, and the bottom row represents voting against. The first column represents environments where the party does not happen and Jack's vote didn't matter—either the coin came up heads and the others both voted against, or Kate or Luke became dictator and voted against. The third column similarly represents outcomes where the party happens regardless of how Jack votes. The second column represents all environments in which Jack's vote matters, so either he is dictator, or Kate and Luke's votes were split. Similarly, let D K be the Cartesian frame over V representing Kate's perspective, D K ≃ ( N Y Y N N Y ) . Then, D J ⊗ D K ≃ ⎛ ⎜
⎜
⎜ ⎝ N Y Y Y Y Y N N N Y Y Y N N Y N Y Y N N N N N Y ⎞ ⎟
⎟
⎟ ⎠ . The rows represent, in order: both voting in favor; Jack voting in favor but Kate voting against; Kate voting in favor but Jack voting against; and both voting against. The columns represent, in order: Luke is dictator and votes against; majority rules and Luke votes against; Kate is dictator; Jack is dictator; majority rules and Luke votes in favor; and Luke is dictator and votes in favor. Here, D J ⊗ D K looks more like what we would expect Jack and Kate working together on a team to look like. However, up to biextensional equivalence, D J and D K are the same as p ∘ ( C J ) and p ∘ ( C K ) . When we forget the actual votes and only look at whether the party happens, then up to biextensional collapse, the Cartesian frame representing Jack's perspective no longer has any way to distinguish between the simple majority rule vote and the complicated voting system with coins and dictators. In general, just looking at two Cartesian frames does not tell you all of the information about the relationships between the people we might be using the frames to model. The Cartesian frames over V representing Jack and Kate's perspectives do not have any information that distinguishes between the two vote counting schemes. When taking a tensor, we automatically include all of the possible ways the two agents can embed in each other's environments, even if a given embedding doesn't make sense in a given interpretation. 4. Par Our next multiplicative operation is ⅋ , which is pronounced "par." Definition: Let C = ( A , E , ⋅ ) and D = ( B , F , ⋆ ) be Cartesian frames over W . C ⅋ D = ( hom ( C ∗ , D ) , E × F , ⋄ ) , where ( g , h ) ⋄ ( e , f ) = g ( e ) ⋆ f = h ( f ) ⋅ e . Claim: ⅋ is De Morgan dual to ⊗ , so C ⅋ D = ( C ∗ ⊗ D ∗ ) ∗ . Proof: Trivial. □ ⅋ has much less of an intuitive interpretation than ⊗ . One reason for this is that in order to par two agents together, they have to be large enough that each other's environments embed within them. If C and D are not large enough, we will have that C ⅋ D ≃ 0 . (I am being informal with the word "large" here.) One way that C and D can fail to be large enough is if Ensure ( C ∗ ) ∩ Prevent ( D ∗ ) is nonempty, which is dual to the above result about tensor being for disjoint agents. It is actually pretty difficult for C and D to be large enough. If there is any fact about the world that is determined outside of both agents, C ⅋ D will be trivial. We had a dual restriction for ⊗ , but it didn't get in the way nearly as often: simple intuitive examples tend to be about small agents interacting with a large environment, so it is easy to imagine two agents that are disjoint. It is much harder to imagine simple examples of two agents that cover, which (informally) is what you would have to have for ⅋ to be nontrivial. I expect to not use ⅋ very often, but I am including it here for completeness. Claim: ⅋ is commutative and associative, and ⊥ is the identity of ⅋ (up to isomorphism). Proof: Trivial from the fact that ⅋ is De Morgan dual to ⊗ and 1 ∗ ≅ ⊥ . □ Claim: If C 0 ≃ C 1 and D 0 ≃ D 1 , then C 0 ⅋ D 0 ≃ C 1 ⅋ D 1 . Proof: Trivial from the fact that ⅋ is De Morgan dual to ⊗ , and ≃ is preserved by − ∗ . □ Claim: ⅋ distributes over & , so for all Cartesian frames C 0 , C 1 , and D , we have ( C 0 & C 1 ) ⅋ D ≅ ( C 0 ⅋ D ) & ( C 1 ⅋ D ) . Proof: Trivial from the fact that ⅋ is De Morgan dual to ⊗ , and & is De Morgan dual to ⊕ . □ 5. Lollipop We have one more operation to introduce, ⊸ (pronounced "lollipop"), which is a Cartesian frame that can be thought of as representing the collection of morphisms between two Cartesian frames. Definition: Given two Cartesian frames over W , C = ( A , E , ⋅ ) and D = ( B , F , ⋆ ) , we let C ⊸ D denote the Cartesian frame C ⊸ D = ( hom ( C , D ) , A × F , ⋄ ) , where ⋄ is given by ( g , h ) ⋄ ( a , f ) = g ( a ) ⋆ f = a ⋅ h ( f ) . One way to interpret C ⊸ D is as " D with a C -shaped hole in it." Indeed, let us think about Agent ( C ⊸ D ) . and Env ( C ⊸ D ) separately. Agent ( C ⊸ D ) = hom ( C , D ) is the collection of morphisms from C to D . Morphisms from C to D are exactly interfaces through which the agent of C can interact with the environment of D . We can also think of this as the collection of interfaces that allow the agent of C to fill the role of the agent of D . This makes sense. The collection of ways that a " D with a C -shaped hole in it" can be is exactly the collection of interfaces that allow us to get a possible agent of D from a possible agent of C . Similarly, Env ( C ⊸ D ) = A × F makes sense as the environment of a " D with a C -shaped hole in it." The environment needs to supply an environment for D , and also fill in the hole with an agent for C . Previously, C 's agent might have been part of D 's agent; in C ⊸ D , however, this part of D gets moved into the environment. Imagine a football team D with one team member, C , removed—the team with a football-player-shaped hole in it. Its environment, naturally, is pairs of "the kind of environment you get for a football team" and "the removed teammate". Lollipop can be easily constructed from our other operations. Claim: C ⊸ D ≅ C ∗ ⅋ D ≅ ( C ⊗ D ∗ ) ∗ . Proof: Trivial. □ Lollipop is well-defined up to biextensional equivalence. Claim: If C 0 ≃ C 1 and D 0 ≃ D 1 , then C 0 ⊸ D 0 ≃ C 1 ⊸ D 1 . Proof: Trivial. □ Lollipop also has some identity-like properties. Claim: For all Cartesian Frames C , C ≅ 1 ⊸ C and C ∗ ≅ C ⊸ ⊥ . Proof: 1 ⊸ C ≅ ( 1 ⊗ C ∗ ) ∗ ≅ C ∗ ∗ ≅ C and C ⊸ ⊥ ≅ ( C ⊗ 1 ) ∗ ≅ C ∗ . □ This last result is especially interesting because we can actually think of C ⊸ ⊥ as an alternative definition for C ∗ . In "Tensor is Relative to a Coarse World Model" above, we noted that two agents working together might sometimes have strictly fewer possible environments than show up in the tensor. In the next post, we will introduce the concept of a sub-tensor , which allows us to represent teams that have fewer possible environments than the tensor. Similarly, sub-sum will be sum with spurious possible environments removed.