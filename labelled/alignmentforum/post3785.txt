A putative new idea for AI control; index here . "Guarded learning" is a model for unbiased learning, the kind of learning where the AI has an incentive to learn its values, but not to bias the direction in which it learns. The value-uncertain U Assume the AI is uncertain between n + 1 different utilities v 0 , v 1 , … , v n . Its actual utility is U = I 0 v 0 + I 1 v 1 + … I n v n where the I j are indicator functions with I j ≥ 0 and ∑ j I j = 1 . The learning process is whatever updates the AI's estimates for the I j . Writing the utility in this way means that the utility of future actions will be assessed according to the values of the future agent (as long as the current agent can trust the future agent's assessment of the I j ), thus avoiding the naive cake or death problem . At any given time, the expectations of I 0 , I 1 , … , I n define a weighted sum of v j , which can be seen as a point on n -simplex Δ n . Define U t as the utility given by these expectations at time t . For any w ∈ Δ n , define π w as the policy that maximises the invariant utility function w . Thus if U t = w , a U -maximiser will not necessarily follow π w , because U t + 1 might be different from w , while π w always maximises w . At any given time t , define the function f t : Δ n → R my mapping w to E t ( w | π w ) . This is the expectation of w at t , given that the AI follows a w -maximising policy. Defining these f t requires some sort of logical or causal counterfactual -- "given that the AI follows π w " -- but this is the only requirement in this setup. The f t are all convex, see the proof at the end of this post. Value updating and correction For illustration, consider the case n + 1 = 2 . The 1 -simplex Δ 1 is a line segment, which we're identifying with [ 0 , 1 ] : The green curve is the plot of f t . The blue line connects f t ( v 0 ) = E t ( v 0 | π v 0 ) with f t ( v 1 ) = E t ( v 1 | π v 1 ) . The purple line is E t ( v | π v 0 ) while the yellow line is E t ( v | π v 1 ) . The f t curve must be contained between these lines . The AI currently has U t = 0.5 v 0 + 0.5 v 1 . If the AI expected to learn more about its values, then its expected utility would rise along the green arrow. Reaching the top, on the blue line, corresponded to a situation where the agent expected to imminently be informed of whether its utility is v 0 or v 1 , and thus transform itself into a v 0 or v 1 maximiser. This kind of learning, up the green arrow, is what we want to encourage (note that this doesn't make the learning safe , though -- we need to pick the update process with care). The red arrows point to updates we want to discourage -- we don't want the AI to manipulate the direction of its update to get higher utility (in this case, by moving towards v 0 ). Correction term Consider the agent operating as a discrete agent, moving from time t to time t + 1 . It choose an action a t ; as a consequence of that, at time t + 1 , it expects a probability distribution over possible U t + 1 . If we assume that there are only finitely many possibilities { U i t + 1 } (the continuous case is almost identical), then define p i = P t ( U t + 1 = U i t + 1 | a t ) . Let E U t + 1 be the expectation of U t + 1 , that is E ( U t + 1 | a t ) = ∑ i p i U i t + 1 . Then a t is an unbiased action (corresponding to moving up the blue arrow) if E U t + 1 = U t . One restriction we could do would be to require all valid a t to satisfy this. But this might be extremely restrictive. For instance, we probably wouldn't mind if ( U 0 t + 1 , p 0 ) = ( v 0 , 0.51 ) and ( U 1 t + 1 , p 1 ) = ( v 1 , 0.49 ) . That's the green point here: Sure, the green point is slightly off-centre, but the AI has gained a lot of information. What's clearly incorrect, is if ( U 0 t + 1 , p 0 ) = ( v 0 , 1 ) . This is the red point in the above graph; the action a t has forced the AI's values straight to v 0 . One way of dealing with the "force the values to v 0 " would be to require the AI to use its past values U t = 0.5 v 0 + 0.5 v 1 rather than its future values U t + 1 = v 0 to evaluate the quality of the update. This would be like imposing the naive cake or death problem on the agent. The expectation would be E t ( 0.5 v 0 + 0.5 v 1 | π v 0 ) , which is the orange point on the line here: This solves the for the AI forcing the value of U t + 1 to a single value, but we need to extend it to (biased) distributions over multiple U i t + 1 's. The natural way to do that is to define the penalty: Penalty for biased a t = E t ( U t | π t + 1 ) − E t ( E U t + 1 | π t + 1 ) , where π t + 1 is the subsequent policy. It's clear the penalty is 0 when E U t + 1 = U t . However, the penalty is not always negative! Indeed, upon forcing U t + 1 = 0.25 v 0 + 0.75 v 1 , adding the penalty would move the agent's utility to the orange point, higher than the red one: Thus the penalty makes certain biased choice, that would otherwise be negative, slightly less negative. What is clear, however, is that, even with a positive penalty, it's always better for the AI to keep U t + 1 = U t than to force U t + 1 to the single value v ≠ U t + 1 (ie the blue point is still higher than the orange one). This is because it's total reward would then be E t ( v | π v ) + ( E t ( U t | π v ) − E t ( v | π v ) ) = E t ( U t | π v ) ≤ E t ( U t | π U t ) by the definition of π U t . So, in order to get a positive expectation from a biased action, the AI has to get a gain in information to overcome this loss. Subagent stability Is this penalty design subagent stable? It's not clear. Creating a subagent without the penalty is not an action the AI would go (as that action means its expectation of U t + 1 will become very biased, as the subagent has no restriction on deliberately biasing the values of I j ). However, an AI with U t = 0.5 v 1 = 0 + 0.5 v 1 would certainly create a subagent that randomly decided to force either U t + 1 = v 0 or U t + 1 = v 1 . Convexity of f t This section will prove the following theorem: Theorem : If the AI's utility depends only on its actions, the f t are convex. Proof : For any v ∈ Δ n , there is a map g v : Δ n → R that maps w to E t ( w | π v ) . This map is linear, and ( w , g v ( w ) ) defines an affine hyper-segment that contains f t ( v ) = g v ( v ) . Then we need to note that the curve ( w , f t ( w ) ) cannot have a transverse intersection with ( w , g v ( w ) ) (though they can be tangent on a convex subset). This is because a transverse intersection would imply there exists a w with f t ( w ) < g v ( w ) , ie E t ( w | π w ) < E t ( w | π v ) . But this is contradicted because π w is defined to be the best policy for maximising w . Thus ( w , g v ( w ) ) is a supporting hyperplane for ( w , f t ( w ) ) , and hence, by the supporting hyperplane theorem, ( w , f t ( w ) ) is convex.