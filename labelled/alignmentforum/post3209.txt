If you haven't read part 1, read it here . In this post we extend the notion of propositional graphs to cover any first order theory. Consider some arbitrary first order theory. For example a theory of integers. We can consider the program to deal with two basic types. B = { ⊤ , ⊥ } and N = { 0 , 1 , 2 , . . . } . All the functions and transformation rules in the previous post apply to B . For example, ⊤ is of type B . ∧ is a function from B 2 → B . 3 and 7 are of type N , and < is a function from N 2 → B . So 3 < 7 is a valid Boolean that can be treated just like p with respect to the propositional transformations. ie ( 3 < 7 ) ∧ p ≡ p ∧ ( 3 < 7 ) . We can also add S : N → N the successor function. Here are some more equivalence rules you might want. S α < S β ≡ α < β α < 0 ≡ ⊥ 0 < S α ≡ ⊤ ¬ ( α < β ) ≡ β < S α In general, there is a finite list of types. Call them X 1 , X 2 , . . . X n All functions have a fixed number of inputs, each with a fixed type, and output something of a fixed type. In our parse tree from before, this means that our edges have one of finitely many different colours, and that each symbol node has a fixed pattern of colors for its inputs and outputs. + is a node of type N and both its children are of type N . < is a node of type B , and both its children are of type N . ¬ is of type B and has one child of type B . Where the output type is not clear, it may be indicated by a subscript. < B ( 3 N , 5 N ) Before we can get to predicate logic, we will introduce a set of implicit variable symbols V X for each type X in use. V = ∪ n x = 1 V X is the set of all implicit variables. An implicit variable is an abstract symbol like ⊥ or 3 . Specific implicit variables will be represented by capital roman letters (ABC). Substitution rules can also contain references to arbitrary members of some V X . Eg Sub ( Γ N , δ N , + N ( α N , β N ) ) ≡ + N ( Sub ( Γ N , δ N , α N ) , Sub ( Γ N , δ N , β N ) ) Sub ( Γ N , δ N , Γ N ) ≡ δ N Here Sub is the substitution function, the α N , β N , δ N represent any expression that has a real type. The Γ N represents any single symbol from the set V N . Applying these equivalences tells us that Sub ( X , 5 , + ( 3 , X ) ) ≡ + ( Sub ( X , 5 , 3 ) , Sub ( X , 5 , X ) ) ≡ + ( Sub ( X , 5 , 3 ) , 5 ) If 3 is a shorthand for S ( S ( S ( 0 ) ) ) then the rules Sub ( Γ N , δ N , S ( α N ) ) ≡ S ( Sub ( Γ N , δ N , α N ) ) and Sub ( Γ N , δ N , 0 N ) ≡ 0 N allow deduction all the way to + ( Sub ( X , 5 , 3 ) , 5 ) ≡ 8 A general first order theory makes use of = and ∀ as well as [ / ] for substitution. These do not need any special properties, and can be defined by the normal substitution rules. Technically there is a collection of Sub 's, one for each pair of types. We have 4 axioms, which can be turned into rules by making them all equivalent to ⊤ . ∀ B ( Γ N , = B , ( Γ N , Γ N ) ) ≡ ⊤ ∀ B ( Γ N , ∀ ( Δ N , ⟹ B ( = B ( α N , β N ) , = B ( ϕ B , Sub ( Γ N , Δ N , ϕ B ) ) ) ) ) ≡ ⊤ ⟹ B ( ∀ B ( Γ N , ϕ B ) , Sub ( Γ N , α N , ϕ B ) ) ≡ ⊤ ⟹ B ( ∀ N ( Γ N , ⟹ B ( ϕ B , ψ B ) ) , ⟹ B ( ∀ N ( Γ N , ϕ B ) , ∀ N ( Γ N , ψ B ) ) ) And a rule that allows generalization. ∀ N ( Γ N , ⊤ ) ≡ ⊤ I believe that this set of substitution rules, or something like it, can produce predicate logic. I also believe that more substitution rules and symbols can be added to make any first order theory. The intuition is that you can take any proof in any first order logical theory and convert it into a series of substitution rules by anding in any axioms, and applying moduls ponens. Generalization can be done by turning ⊤ into ∀ ( X , ⊤ ) and then using substitutions not dependent on X to turn it into ∀ ( X , p ) . Theorem For any set of symbols with appropriate type signatures, for any recursively enumerable equivalence relation H . (With the property that a ≡ b ⟹ f ( a ) ≡ f ( b ) )There exists a finite set of extra symbols and a finite set of substitution rules such that these equivalences hold. Proof Outline Introduce the symbols 0,1,end so that binary strings can be stored 0(1(1(0(end)))) Give them some new type Y, and add a load of type converters, symbols that take in an object of type Y, and output some other type. Introduce + for concatenation. + ( 0 ( α Y ) , β Y ) ≡ 0 ( + ( α Y , β Y ) ) And the same for 1 + ( e n d , α Y ) ≡ α Y By adding the rules P ( α , 0 ( β ) ) ≡ 0 ( P ( 0 ( α ) , β ) ) P ( α , 1 ( β ) ) ≡ 0 ( P ( 1 ( α ) , β ) ) P ( α , e n d ) ≡ 1 ( α ) Then if | α | = n then P ( e n d , α ) ≡ 0 n 1 r e v e r s e ( α ) . This means that J ( α , β ) ≡ + ( P ( e n d , α ) , P ( e n d , β ) ) can unambiguously express pairs of bitstrings as a single bitstring. Arbitrary syntax trees can be encoded like ∗ ( C o n v N ( α Y ) , C o n v N ( β Y ) ) ≡ C o n v N ( J ( 010 e n d , J ( α Y , β Y ) ) ) Where 010 is the unique bitstring representing "*", an arbitrary symbol. Then add a rule that C o n v N ( α Y ) ≡ r i g h t N ( T M 1 ( l e f t ( J ( α Y , β Y ) ) ) ) As β Y can be anything, it could be an encoding of what you want. Then we let l e f t ( 0 ( α ) ) ≡ 0 ( l e f t ( α ) ) and the same for one, to run l e f t to the far end of the bitstring. Then l e f t ( e n d ) ≡ n ( l e f t ( e n d ) ) where n is a null symbol for tape that doesn't store data and we can extend tape as needed. Using rules like T M 1 ( n ( α ) ) ≡ 1 ( T M 3 ( α ) ) we can run any turing machine with one symbol per state. Then finally we have a rule like T M 4 ( 0 ( α ) ) ≡ s u c c e s s ( T M 4 ( 0 ( α ) ) ) . Let success commute with 0,1 so it can go up to the top.  Let r i g h t ( s u c c e s s ( α ) ) ≡ r i g h t ( s u c c e s s ( n ( α ) ) ) . Then  you can unwind all the computations, and r i g h t N ( s u c c e s s ( T M 1 ( l e f t ( J ( α Y , β Y ) ) ) ) ) ≡ C o n v N ( β y ) means that you can take the bit stream that you computed to be equal, and decode it back into its symbols. Lemma Any possible computably checkable  formal proof system can be converted into an equivalence graph. Post Ending. Next time we will see when different proof systems are provably the same. I know the formatting is rough and the explanations aren't always as clear as could be. Tell me about any unusually opaque parts. If these ideas turn out to be important, someone will need to rework this. I know the axioms used are not the simplest possible, and proofs are not fully formalized.