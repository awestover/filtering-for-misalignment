Abstract This paper presents ProLU , an alternative to ReLU for the activation function in sparse autoencoders that produces a pareto improvement over both standard sparse autoencoders trained with an L1 penalty and sparse autoencoders trained with a Sqrt(L1) penalty. ProLU ( m i , b i ) = { m i if m i + b i > 0 and m i > 0 0 otherwise SAE ProLU ( x ) = ProLU ( ( x − b d e c ) W e n c , b e n c ) W d e c + b d e c The gradient wrt. b is zero, so we generate two candidate classes of differentiable ProLU : ProLU R e L U ∂ ∗ ProLU R e L U ( m i , b i ) ∂ b i = ∂ ProLU R e L U ( m i , b i ) ∂ m i = { 1 if m i + b i > 0 and m i > 0 0 otherwise ProLU S T E ∂ ∗ ProLU S T E ( m i , b i ) ∂ m i = { 1 + m i if m i > 0 and m i + b i > 0 0 otherwise ∂ ∗ ProLU S T E ( m i , b i ) ∂ b i = { m i if m i > 0 and m i + b i > 0 0 otherwise PyTorch Implementation Introduction SAE Context and Terminology Learnable parameters of a sparse autoencoder: W e n c : encoder weights W d e c : decoder weights b e n c : encoder bias b d e c : decoder bias The output of an SAE is given by S A E ( x ) = ReLU ( ( x − b d e c ) W e n c + b e n c ) W d e c + b d e c Training Notation: Encoder/Decoder Let encode ( x ) = ReLU ( ( x − b d e c ) W e n c + b e n c ) decode ( a ) = a W d e c + b d e c so that the full computation done by an SAE can be expressed as SAE ( x ) = decode ( encode ( x ) ) An SAE is trained with gradient descent on L t r a i n = | | x − S A E ( x ) | | 2 2 + λ P ( encode ( x ) ) where λ is the sparsity penalty coefficient (often "L1 coefficient") and P is the sparsity penalty function, used to encourage sparsity. P is commonly the L1 norm | | a | | 1 but recently P ( a ) = | | a | | 1 2 1 2 has been shown to produce a Pareto improvement on the L0 and CE metrics. We will use this as a further baseline to compare against when assessing our models in addition to the standard ReLU -based SAE with L1 penalty. Motivation: Inconsistent Scaling in Sparse Autoencoders Due to the affine translation, sparse autoencoder features with nonzero encoder biases only perfectly reconstruct feature magnitudes at a single point. This poses difficulties if activation magnitudes for a fixed feature tend to vary over a wide range. This potential problem motivates the concept of scale consistency: A scale consistent response curve The bias maintains its role in noise suppression, but no longer translates activation magnitudes when the feature is active. The lack of gradients for the encoder bias term poses a challenge for learning with gradient descent. This paper will formalize an activation function which gives SAEs this scale-consistent response curve, and motivate and propose two plausible synthetic gradients, and compare scale-consistent models trained with the two synthetic gradients to standard SAEs and SAEs trained with Sqrt(L1) penalty. Scale Consistency Desiderata Notation: Centered Submodule The use of the decoder bias can be viewed as performing centering on the inputs to a centered SAE then reversing the centering on the outputs: S A E ( x ) = S A E c e n t ( x − b d e c ) + b d e c S A E c e n t ( x ) = ReLU ( x W e n c + b e n c ) W d e c Notation: Specified Feature Let W i denote the weights and b i e n c the encoder bias for the i -th feature. Then, let S A E i ( x ) = S A E i c e n t ( x − b d e c ) + b d e c where S A E i c e n t ( x ) = ReLU ( x W i e n c + b i e n c ) W i d e c Conditional Linearity 1. S A E i c e n t ( v 1 ) > 0 ∧ S A E i c e n t ( v 2 ) > 0 ⟹ S A E i c e n t ( v 1 ) + S A E i c e n t ( v 2 ) = S A E i c e n t ( v 1 + v 2 ) 2. ∀ v S A E i c e n t ( v ) > 0 ∧ k > 1 ⟹ S A E i c e n t ( k v ) = k ⋅ S A E i c e n t ( v ) Noise Suppresion Threshold 3. b e n c < 0 ⟹ ∃ η ∈ ( 0 , ∞ ) ∀ ϵ ∈ ( 0 , ∞ ) s.t. S A E i c e n t ( η ⋅ v ) = 0 ∧ S A E i c e n t ( ( η + ϵ ) ⋅ v ) > 0 Proportional ReLU ( ProLU ) The concept of using a thresholding nonlinearity instead of a learned bias term for inhibition autoencoders was introduced a decade prior to this work in "Zero-Bias Autoencoders and the Benefits of Co-adapting Features." Their TRec activation function is very similar to ProLU, with the following key differences: ProLU has a different threshold parameter for each hidden unit Learning of ProLU's threshold parameter ( b i ) is enabled via psuedoderivatives We define the base (without psuedoderivatives not yet defined) Pro portional Re LU ( ProLU ) as: ProLU ( m i , b i ) = { m i if m i + b i > 0 and m i > 0 0 otherwise Backprop with ProLU : To use ProLU in SGD-optimized models, we first address the lack of gradients wrt. the b term. ReLU gradients: For comparison and later use, we will first consider ReLU : partial derivatives are well defined for ReLU at all points other than x i = 0 : ∂ ReLU ( x i ) ∂ x i = { 1 if x i > 0 0 if x i < 0 Gradients of ProLU : Partials of ProLU wrt. m are similarly well defined: ∂ ProLU ( m i , b i ) ∂ m i = { 1 if m i + b i > 0 and m i > 0 0 otherwise However, they are not well defined wrt. b , so we must synthesize these. Related Work [Zero-bias autoencoders and the benefits of co-adapting features] introduced zero-bias autoencoders which are very related to this work. The ProLU SAE can be viewed as a zero-bias autoencoder where the threshold parameter theta is learned using straight-through estimators and which uses an L1 penalty to encourage sparsity Methods Notation: Synthetic Gradients Let ∂ ∗ f ∂ x denote the synthetic partial derivative of f wrt. x , and ∇ ∗ f the synthetic gradient of f, used for backpropagation as a stand-in for the gradient. Different synthetic gradient types We train two classes of ProLU with different synthetic gradients. These are distinguished by their subscript: ProLU R e L U ProLU S T E They are identical in output, but have different synthetic gradients. I.e. ProLU R e L U ( m , b ) = ProLU S T E ( m , b ) ∇ ∗ ProLU R e L U ( m , b ) ≢ ∇ ∗ ProLU S T E ( m , b ) Defining ProLU R e L U : ReLU -like gradients The first synthetic gradient is very similar to the gradient for ReLU . We retain the gradient wrt. m , and define the synthetic gradient wrt. b to be the same as the gradient wrt. m : ∂ ∗ ProLU R e L U ( m i , b i ) ∂ b i = ∂ ProLU R e L U ( m i , b i ) ∂ m i = { 1 if m i + b i > 0 and m i > 0 0 otherwise Defining ProLU S T E : Derivation from straight-through estimator The second class of ProLU uses synthetic gradients for both b and m and can be motivated by framing ProLU and ReLU in terms of the threshold function, and a common choice of straight-through estimator (STE) for the threshold function. This is a plausible explanation for the observed empirical performance but it should be noted that there are many degrees of freedom and possible alternative Setup The threshold function Thresh is defined as follows: Thresh ( x ) = { 1 if x > 0 0 otherwise We will rephrase the partial derivative of ReLU in terms of the threshold function for ease of later notation: ∂ ReLU ( x i ) ∂ x i = { 1 if x i > 0 0 if x i < 0 = Thresh ( x i ) It is common to use a straight-through estimator (STE) to approximate the gradient of the threshold function: ∂ ∗ Thresh ( x i ) ∂ x i = S T Thresh ( x i ) We can reframe ProLU in terms of the threshold function: ProLU ( m i , b i ) = ReLU ( m i ) ⋅ Thresh ( m i + b i ) Synthetic Gradients wrt. m Now, we take partial derivatives of ProLU wrt. m using the STE approximation for the threshold function: ∂ ∗ ProLU S T E ( m i , b i ) ∂ m i = ∂ ∗ ∂ m i ( ReLU ( m i ) ⋅ Thresh ( m i + b i ) ) = ∂ ReLU ( m i ) ∂ m i ⋅ Thresh ( m i + b i ) + ReLU ( m i ) ⋅ ∂ ∗ Thresh ( m i + b i ) ∂ m i = Thresh ( m i ) ⋅ Thresh ( m i + b i ) + ReLU ( m i ) ⋅ S T Thresh ( m i + b i ) = Thresh ( m i ) ⋅ Thresh ( m i + b i ) + m i Thresh ( m i ) ⋅ S T Thresh ( m i + b i ) Synthetic Gradients wrt. b ∂ ∗ ProLU S T E ( m i , b i ) ∂ b i = ∂ ∗ ∂ b i ( ReLU ( m i ) ⋅ Thresh ( m i + b i ) ) = ∂ ReLU ( m i ) ∂ b i ⋅ Thresh ( m i + b i ) + ReLU ( m i ) ⋅ ∂ ∗ Thresh ( m i + b i ) ∂ b i = 0 ⋅ Thresh ( m i + b i ) + ReLU ( m i ) ⋅ S T Thresh ( m i + b i ) = m i Thresh ( m i ) ⋅ S T Thresh ( m i + b i ) Choice of Straight-Through Estimator There are many possible functions to use for S T Thresh ( x ) . In our experiments, we take the derivative of ReLU as the choice of straight-through estimator. This choice has been used in training quantized neural nets . [1] S T Thresh ( x ) : = Thresh ( x ) then, synthetic gradients wrt. m are given by, ∂ ∗ ProLU S T E ( m i , b i ) ∂ m i = Thresh ( m i ) ⋅ Thresh ( m i + b i ) + m i Thresh ( m i ) ⋅ Thresh ( m i + b i ) = ( 1 + m i ) ⋅ Thresh ( m i ) ⋅ Thresh ( m i + b i ) = { 1 + m i if m i > 0 and m i + b i > 0 0 otherwise and wrt. b are given by, ∂ ∗ ProLU S T E ( m i , b i ) ∂ b i = m i Thresh ( m i ) ⋅ Thresh ( m i + b i ) = { m i if m i > 0 and m i + b i > 0 0 otherwise ProLU Sparse Autoencoder We can express the encoder of a ProLU SAE as encode ProLU ( x ) = ProLU ( ( x − b d e c ) W e n c , b e n c ) No change is needed to the decoder. Thus, SAE ProLU ( x ) = decode ( encode ProLU ( x ) ) Experiment Setup Shared among all sweeps: Adam optimizer, with: β 1 = 0.9 , β 2 = 0.999 batch size = 4096 Data Trained on gpt2 layer 6 pre-residual activations Tokens: ~400m tokens from The Pile @ack(Alan Cooney's pre-tokenized pile) -> ~100k gradient steps LR schedule Warmup for 2 1 − β 2 = 2 , 000 steps in accordance with On the adequacy of untuned warmup for adaptive optimization Linear warmup after each resample. Same value 2,000 Linear cooldown to 1/10 initial value over 20,000 steps starting at 75,000 steps Anthropic resampling I used 3e-6 as the dead threshold rather than 0 Resample at 25,000 and 50,000 steps The proportion of the average encoder norm resampled to varied between sweeps Normalization: L2 normalization as proposed by Anthropic SAE details Dictionary expansion factor of 16 Tied decoder bias, untied encoder/decoder weights Varying between sweeps: Experiment 1: l r = 0.001 30 total runs Resampled to 0.02 of avg encoder norm Experiment 2: l r = 0.0003 48 total runs Resampled to 0.02 of avg encoder norm Experiment 3: l r = 0.001 30 total runs Resampled to 0.2 of avg encoder norm adjusted L1-coefficient ranges for each model, to get more overlap in L0 ranges. different architectures respond very differently to l1 coefficients Varying within sweeps L1 coefficient Architecture choice of nonlinearity: ReLU ProLU R e L U ProLU S T E L1 Penalty type L1: P ( a ) = | | a | | 1 Sqrt(L1): P ( a ) = | | a | | 1 / 2 1 / 2 Results Let: L m o d e l be the CE loss of the model unperturbed on the data distribution L r e c o n s t r u c t e d be the CE loss of the model when activations are replaced with the reconstructed activations L z e r o be the CE loss of the model when activations are replaced with the zero vector Degradation: or Information Lost . This measures how much information about the correct next token the model loses by having its activations a replaced with the SAE's reconstruction SAE ( a ) . degradation = L r e c o n s t r u c t e d − L m o d e l For L 0 < 25 : The pareto-best architecture uses the ProLU S T E nonlinearity with an L1 sparsity penalty. For L 0 > 25 : There are no occurrences of models using ProLU S T E with L1 penalty in this L0 range Of the remaining models, ProLU ReLU with Sqrt(L1) penalty is pareto-best. Further Investigation MSE/L1 Pareto Frontier The gradients of ProLU are not the gradients of the loss landscape, so it would be a reasonable default to expect these models to perform worse than a vanilla SAE. Indeed I expect they may perform worse on the optimization target , and that the reason why this is able to work is there is slack in the problem introduced by us being unable to optimize for our actual target directly -- our current options are to optimize for L1 or Sqrt(L1) as sparsity proxies for what we actually want because L0 is not a differentiable metric. Actual target: minimize L0 and bits lost Optimization (proxy) target: minimize L1 (or √ L 1 )) and MSE Because we're not optimizing for the actual target , I am not so surprised that there may be weird tricks we can do to get more of what we want. On this vein of thought, my prediction after seeing the good performance  on the actual target (and prior to checking this prediction) was: Despite improved performance on degradation/L0 ProLU SAEs will have the same or worse on the MSE/L1 curve. We may also see the higher performing architectures have greater L1/L0 Let's check: In favor of the hypothesis, while other architectures sometimes join it on the frontier, the Vanilla ReLU is present for the entirety of this Pareto frontier. On the other hand, at lower sparsity levels ProLU S T E joins it at the frontier. So the part where this change does not improve performance on the optimization target seems true, but it's not clear that better performance on the actual target is coming from worse performance on the optimization target. This suggests a possible reason for why the technique works well: Possibly the gains from this technique do not come from scale consistency so much as that it forced us to synthesize some gradients and those gradients happened to point more in the direction of what we actually want . Here is the graph of L1 norm versus L0 norm: This looks like it's possible that what is working well here is the learned features are experiencing less suppression ,  but that may not be the only thing going on fixing this. Feature suppression is still consistent with the scale consistency hypothesis, as consistent undershooting would be an expected side effect if that is a real problem, since regular SAEs may be less able to filter unwanted activations if they are keeping biases near zero in order to minimize errors induced by scale inconsistency. More investigation is needed here to create a complete or confident picture of what is cause of the performance gains in ProLU SAEs. Unfortunately, I did not log √ L 1 so I can't compare with that curve, but could load the models to create those graphs in follow-up work. Acknowledgements Noa Nabeshima and Arunim Agarwal gave useful feedback and editing help on the draft of this post. Mason Krug for in depth editing of my grant proposal, which helped seed this writeup and clarify my communication. How to Cite @misc{ProLUNonlinearity,
   title = {ProLU: A Nonlinearity for Sparse Autoencoders},
   author = {Glen M. Taggart},
   year = {2024},
   howpublished = {\url{https://www.alignmentforum.org/posts/HEpufTdakGTTKgoYF/prolu-a-nonlinearity-for-sparse-autoencoders}},
} ^