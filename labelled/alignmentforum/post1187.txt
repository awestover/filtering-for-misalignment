TLDR: I sketch a language for describing (either Bayesian or infra-Bayesian) hypotheses about computations (i.e. computable [1] logical/analytic facts). This is achieved via a novel (AFAIK) branch of automata theory, which generalizes both ordinary and tree automata by recasting them in category-theoretic language. The resulting theory can be equipped with a intriguing self-referential feature: automata that "build" and run new automata in "runtime". Epistemic status: this is an "extended shortform" i.e. the explanations are terse, the math is a sketch (in particular the proofs are not spelled out) and there might be errors (but probably not fatal errors). I made it a top-level post because it seemed worth reporting and was too long for a shortform. Motivation Finite-state automata are a convenient tool for constructing hypotheses classes that admit efficient learning. A classical example is MDPs in reinforcement learning. Ordinary automata accept strings in input. This is convenient when the input is a time sequence. However, in Turing Reinforcement Learning and infra-Bayesian physicalism we want to equip our agent with beliefs about computations , which don't form a time sequence in the ordinary sense. Computations are often represented as trees: e.g. syntax trees of lambda calculus, or any other functional programming language, or expressions defining recursive functions. Hence, the obvious guess is using tree automata . Specifically, we will focus on bottom-up tree automata which are more powerful and more convenient for other reasons as well. One limitation of this is that hypotheses described using (infra-)probabilistic tree automata are missing correlations between computations. Even if two programs contain a literally identical subroutine, or a single program uses multiple copies of an identical subroutine, the uncertainty is about the different copies is uncorrelated. Another limitation is that sophisticated automata might require exponentially many states, meaning that a straightforward (tabular) description of the transition rules is exponentially large. Instead, we would like a convenient compositional language for constructing such automata (analogously [2] to the compositional language I proposed for MDPs). Therefore, a generalization is called for. Deterministic Operadic Automata Bottom-up deterministic tree automata are algebras over the operad of trees [3] (modulo accepting states, which are not encoded in the algebra structure). More precisely, they are algebras over the free operad generated by the input alphabet of the tree automaton, where the arity of each symbol in the alphabet becomes the operadic arity of the corresponding generator. The transition rules of the tree automaton are the operations in the algebra. So, we can now define a deterministic automaton over a (colored) operad O to be an O -algebra. The automaton is "finite" when the colors are a finite set, and the algebra elements of each color are a finite set. An example application is: take the operad of lambda terms, quotient by η -reduction and α -conversion, and add the renaming of free variables as additional operations into the operad. This leads to hypotheses-about-lambda-expressions which have a better inherent understanding of the semantics. On the other hand, the finiteness condition seems too restrictive now. But, maybe we can get away with, finite number of orbits under the action of the variable-renaming group. More generally, it is not clear which operads lead to a computationally-convenient notion of automaton (similarly how many problems are computationally/statistically tractable for ordinary automata): this seems like a good problem to investigate. Deterministic Operadic Transducers The automata-theoretic notion of "transducer" also has a natural operadic analogue. However, in full generality, this analogue turns out to be much more powerful than classical transducers, even if the underlying operad is just the operad of the free monoid over some alphabet (i.e. in the case where operadic automata are just ordinary automata) [4] : ordinary transducers can only add symbols to the end of the output as they process new input symbols, whereas operadic transducers can e.g. add symbols to the beginning, or write into two "working tapes" s.t. the output is their concatenation . Given an operad O , we define the associated "state operad" [5] O S as follows. Define " O -signature" to be a pair of (i) a list of O -colors (the input types) and (ii) an O -color (the output type). A color A of O S is a set S ( A ) (the "state space"), and for each x ∈ S ( A ) , a finite tuple V ( x ) of O -signatures (the "variables" defined at the given state). An operation of O S is a mapping f : ∏ i S ( A i ) → S ( B ) (where A i are the the input colors and B is the output color) and, for each x ∈ ∏ i S ( A i ) and σ ∈ V ( f ( x ) ) , an operation of signature σ in the operad freely generated by O and generators corresponding to the components of V ( x i ) for all i . Given operads O 1 , 2 and A , B respective colors, a determinsitic operadic transducer from A to B can now be defined as an operad morphism F from O 1 to O S 2 s.t. for any x ∈ S ( F ( A ) ) , the tuple V ( x ) starts with a 0 -ary signature whose output color is B . Given such F , we can transform any 0 -ary operation with output color A to a 0 -ary operation with output color B (exercise for the reader). It is also possible to make transducers process morphisms of general signature. We leave out the details, since the notation in the operad setting is unwieldy. We do explain it for cartesian transducers below. Deterministic Cartesian Automata/Transducers It is often convenient to represent programs as directed acyclic graphs (DAGs) rather than trees. Indeed, we want to be able to define a term once and use it multiple types later. Hence, it is natural to look for a flavor of automaton that can process DAGs. This is achieved by replacing operads with cartesian monoidal categories and algebras by strong monoidal functors from the category to S e t . DAGs are thought of as morphisms in a free cartesian category, just like trees are operations in a free operad. Given a cartesian category C , we can define the "state cartesian category" C S as follows. Here, a " C "-signature" is just a pair of objects (source and target). An object A of C S is a set S ( A ) (the "state space"), and for each x ∈ S ( A ) , a finite tuple V ( x ) of C -signatures (the "variables" defined at the given state). A morphism from A to B in C S is a mapping f : S ( A ) → S ( B ) and, for each x ∈ S ( A ) and σ ∈ V ( f ( x ) ) , a morphism of signature σ in the cartesian category freely generated by C and generators corresponding to the components of V ( x ) . Given A , B objects of C S , we have S ( A × B ) = S ( A ) × S ( B ) and V ( x , y ) is the concatenation of V ( x ) and V ( y ) . A determinsitic cartesian transducer is now defined as consisting of: Input cartesian category C and output cartesian category D Primary input C -signature σ 0 = A → B Auxiliary input D -signatures σ 1 … σ n Input state set X Output D -signatures τ 1 … τ m Output state set Y A cartesian functor F from C to D S s.t. (i) S ( F ( A ) ) = X and for any x ∈ X , V ( x ) is a prefix of σ 1 … σ n (ii) S ( F ( B ) ) = Y and for any y ∈ Y , τ 1 … τ m is a prefix of V ( y ) A transducer can accept an element of X and morphisms of signatures σ 0 … σ n and output an element of Y and morphisms of signatures τ 1 … τ m . Compositional language We can now start defining our compositional language for constructing automata. This language describes [6] automata/transducers as string diagrams . There are two types of edges: edges labeled with sets, and edges labeled with a cartesian category C and some C -signature. Vertices are labeled by transducers. Each vertex has incoming edges with labels corresponding to the transducer's input state space and input signatures, and outgoing edges with labels corresponding to the transducer's out state space and output signatures. The edges should be thought of as "wires" that conduct set elements or morphisms of prescribed signature respectively. There is an interesting phenomenon here: string diagrams are in themselves morphisms of some cartesian category (with signature corresponding to labels of the diagram's external edges)! This allows us to get self-referential, and add a special type of vertex in our diagram, which has one input which is a diagram of the same type (with prescribed external edge labels) and some number of other inputs, and whose semantics is applying the diagram to the inputs (where the outputs and other inputs have labels matching the diagram type). I think that without further constraints, the resulting language might be Turing complete: at the very least, it is possible to create an infinite loop by coming up with an input α and a diagram D s.t. D contains a transducer T which transforms α into D , and D runs its input through T and runs another copy of the input through the diagram T outputs. [ EDIT: Actually, this requires T to produce a diagram D which contains T . Unless we allow this explicitly, it shouldn't be possible with "plain" cartesian automata. However, I think it is possible with closed cartesian automata (see below and comment ).] To avoid infinite loops, we can add a counter for the "level of meta" (i.e. the meta-vertex in diagrams of level k can only accept diagrams of level lower than k ). It is also possible to make this counter an ordinal, by representing ordinals in some notation that itself naturally takes the form of trees/DAGs. Although to get a tractable language, we need to impose some strong constraints: even without the meta-vertex, we can get super-exponential blowup because each transducer can increase the size of the content of a variable by a constant factor for every input symbol. Possibly we should require our category to be equipped with some way to measure the "size" of morphisms (i.e. a functor to N , or maybe a lax functor to N regarded as a 2-category using its order), and most transducers to e.g. only increase size by O ( 1 ) . Monadic Cartesian Automata (MCA) So far, everything was determinsitic. But, we want our hypotheses to have probabilistic and maybe also "infra-probabilistic" uncertainty. The obvious way to define probabilistic automata is to replace cartesian categories with Markov categories and replace S e t with e.g. S t o c h (the category of measurable spaces with Markov kernels as morphisms). However, this is poorly suited for our purpose, because (i) we a joint distribution over the outputs of all programs, and (ii) if an identical subroutine is defined multiple times, we want our uncertainty about those copies to be strongly correlated. Intuitively, want we want is allow all automata read from an additional "tape" filled with random bits. This can be naturally expressed using monads. Fix a monad M 0 : S e t → S e t [7] that is equipped with "lax cartesian structure" [5:1] . By this we mean that it has lax monoidal structure μ 0 w.r.t. the monoidal structure of S e t given by products, and this structure satisfies that for any sets X , Y , Z and mappings f : X → Y and g : X → Z , we have M 0 ( ( f × g ) ∘ Δ X ) = μ 0 Y , Z ∘ ( M 0 ( f ) × M 0 ( g ) ) ∘ Δ M 0 ( X ) Here, Δ stands for the diagonal mapping. Also, we require that μ 0 X , Y ∘ ( η X × i d M 0 ( Y ) ) is a strength of M 0 , where η is the monad unit. However, we require neither that μ 0 arises from this strength nor that it makes M 0 commutative (typically neither holds!) We call such a monad "memo monad". The prototypical example is when M 0 ( X ) is the set of binary trees whose leaves are labeled by elements of X [8] . We think of such a tree as a way to select an element of X by reading a stream of bits. Monad multiplication works by attaching the label-trees to the "parent" tree at the corresponding leaves. The monoidal structure works by taking the union of two trees, where each tree is regarded as the subset of { 0 , 1 } ∗ corresponding to the bitstrings that describe the paths from the root to each vertex (imagine placing one tree such that it overlaps the other), and propagating the labels to the leaves in the obvious way. Another example is binary trees whose non-leaf nodes are labeled by symbols from some fixed alphabet Σ . We think of each element of Σ as corresponding to its own stream can be be queried indepedently. We won't spell out the monoidal structure, but imagine running two subroutines one after the other while memoizing all the queries the first subroutine made from the benefit of the second. As opposed to the first example, this monoidal structure is not symmetric. We also need M 0 to be equipped with a strong monad morphism to the monad P F M defined as follows. For any set X , P F M ( X ) : = ∞ ⨆ n = 1 ( X n × D ( [ n ] ) ) Here, [ n ] is the set { 0 , 1 … n − 1 } and D is the distribution monad. We think of these as distributions over a list of outcomes of size n , with each outcome labeled by an element of X . Monad multiplication works by combining concatenation of strings with multiplication of probabilities in the natural way. Importantly, there are canonical monad morphisms from P F M to both the free monoid monad F M and the distribution monad D . The morphism from M 0 to P F M means that M 0 automatically acquires monad morphisms to F M (we will denote it m F M ) and D (we will denote it m D ). In the case of binary trees, this morphism is defined by listing the leaves of the tree in horizontal order and assigning probabilities by postulating a fair coin at each non-leaf vertex. To define automata, we require that our cartesian categories are equipped with a memo monad. Given a cartesian category C with memo monad M , a ( C , M ) -automaton is a strong monoidal functor F : C → S e t together with a natural isomorhism between M 0 ∘ F and F ∘ M which is (i) strong monoidal (ii) makes F a morphism in the 2-category of monads on arbitrary categories (we call this a "memo functor"). Given A , B objects in C and α : A → M ( B ) a morphism, m D ( F ( α ) ) is a Markov kernel from F ( A ) (the initial state of the automaton) to F ( B ) (the final state of the automaton). Notice that, given α 1 : A 1 → B 1 and α 2 : A 2 → B 2 , m D ( F ( α 1 × α 2 ) ) has the marginals m D ( F ( α 1 × α i ) ) , but the corresponding random variables are not independent. (Because of how m D interacts with the monoidal structure of M 0 .) This means we get a non-trivial joint distribution over all morphisms, which is why we introduced monads in the first place. This formalism has an infra-Bayesian analogue as well: it requires replacing D by a the □ monad (and we know it is a monad) and replacing P F M by the corresponding infra-Bayesian monad. We won't spell out the details. Monadic cartesian transducers can be defined, but we won't spell out the definition. The definition is spelled out for the case of closed cartesian transducers (see below), where the notation is a little simpler. Processing DAGs with MCAs As we discussed, programs are DAGs therefore DAGs are the starting point of any chain of transducers we might want to build. DAGs can be naturall regarded as morphisms in a free cartesian category. But how to embed them into a free cartesian category with memo monad? We do it as follows: Assume any "generator" vertex has one outgoing edge (and any number of incoming edge). Such a vertex corresponds to a generator morphism with signature ∏ i A i → M ( B ) , where the A i and B are generator objects and M is the memo monad. A generator morphism α : ∏ i A i → M ( B ) can be transformed to a morphism α K : ∏ i M ( A i ) → M ( B ) as follows. To get α K , we compose (i) the monoidal structure for M (to get from ∏ i M ( A i ) to M ( ∏ i A i ) (ii) M ( α ) (to get from M ( ∏ i A i ) to M 2 ( B ) ) (iii) the monad multiplication of M (to get from M 2 ( B ) to M ( B ) ). The morphisms of form α K can be vertically and horizontally composed with each other in the usual way to evaluate the DAG. In particular, every edge corresponds to M ( A ) for some generator object A . Any external incoming edge labeled by a generator objected A is interpreted as the monad unit on A in order to get from A to M ( A ) . It would be nice to formulate this process as evaluating a string diagram in the corresponding Kleisli category, but for a memo monad the Kleisli category is not even monoidal. Maybe there is some way to make it work, but atm I don't know how. (Monadic) Closed Cartesian Automata/Transducers [ EDIT : This section contains an error, pointed out to me by David Jaz Myers. I don't currently have a working construction of transducers as 1-morphisms in a Kleisli 2-category. It's probably repairable by changing the setting somehow.] It is convenient to require that our cartesian categories are closed , since it allows simplifying the definition of the "state category" 2-functor and improve its properties. We will also require the category to have arbitrary (not just finite) products. Indeed, let C be such a category. Then we define the C S as follows: An object A of C S is a set S ( A ) (the "state space"), and for each x ∈ S ( A ) , an object V A ( x ) of C (the "variables" defined at the given state). A morphism α : A → B in C S is a mapping S ( α ) : S ( A ) → S ( B ) and, for each x ∈ S ( A ) , a morphism V α ( x ) : V A ( x ) → V B ( S ( α , x ) ) . Given A , B objects of C S , we have S ( A × B ) = S ( A ) × S ( B ) V A × B ( x , y ) = V A ( x ) × V B ( y ) Moreover, S ( B A ) = S ( B ) S ( A ) V B A ( f ) = ∏ x ∈ S ( A ) V B ( f ( x ) ) V A ( x ) So far, we could avoid the infinite products by requiring that S ( A ) is finite. But, when C is equipped with a memo monad M , we also want C S to have a memo monad M S . This will require infinite sets. We define M S as follows: S ( M S ( A ) ) : = M 0 ( S ( A ) ) V M S ( A ) ( x ) : = ∏ i ∈ [ | m F M ( S ( A ) ) | ] V A ( m F M ( S ( A ) ) i ) M S is indeed a monad, but to define the memo (monoidal) structure on it, we need additional structure on m P F M . Let X and Y be two sets and consider the following two mappings f 1 , 2 : M 0 ( X ) × M 0 ( Y ) → P F M ( X ) : f 1 : = m P F M ( X ) ∘ p r M 0 ( X ) f 2 : = m P F M ( X ) ∘ M 0 ( p r X ) ∘ μ 0 X , Y In general, this diagram doesn't commute, i.e. f 1 ≠ f 2 . But, we require that it "lax commutes" in the following sense. For any set Z , P F M ( Z ) can be regarded as a category , in which a morphism from ( u , p ) ∈ Z n × D [ n ] to ( v , q ) ∈ Z m × D [ m ] is a mapping α : [ n ] → [ m ] s.t. the following conditions hold: For any i ∈ [ n ] , u i = v α ( i ) . α ∗ ( p ) = q This allows us to regard f 1 and f 2 as functors, and we postulate a natural transformation ϕ X , Y : f 1 → f 2 . We also postulate another natural transformation ϕ ′ X , Y related in the same way to p r Y (it is separate since μ 0 is not symmetric). Since f 1 and f 2 are actually natural transformations in terms of their dependence on X , Y , we require that ϕ and ϕ ′ are 2-natural transformations. Possibly there are more conditions we need to satisfy but we won't try to specify them precisely. In the case of trees/queries, ϕ , ϕ ′ are defined using the observation that, knowing the result of making more queries is sufficient to predict the result of making less queries. We can now define the monoidal structure μ S on M S given the monoidal structure μ on M . Consider some A , B objects in C S . We define S ( μ S A , B ) : = μ 0 S ( A ) , S ( B ) V μ S A , B ( x , y ) i : = i d V A ( x ) ϕ S ( A ) , S ( B ) ( i ) × i d V B ( x ) ϕ ′ S ( A ) , S ( B ) ( i ) As before, a (monadic) closed cartesian automaton is a (memo) cartesian closed functor from C to S e t . A (monadic) closed cartesian transducer from C to D is a (memo) cartesian closed functor from C to D S . Given an object A of C , a transducer F can be regarded as taking morphisms α : 1 → A as inputs producing y and β as outputs, where: y : = S ( F ( α ) ) β : = V F ( α ) Notice that these automata are in general not "finite" in any sense. To have a notion of "finite" automaton/transducer, we need to have a fully faithfull cartesian closed subcategory C f i n of C representing "finite" objects, which (in some sense?) generates all of C if arbitrary products are allowed. We can then define C S f i n to consist of A s.t. S ( A ) is a finite set and for every x ∈ S ( A ) , V A ( x ) is in C f i n . A finite automaton is a functor F s.t. F ( A ) is a finite set whenever A is a finite object, and a finite transducer is a functor F s.t. F ( A ) is a finite object whenever A is. We should probably also require that, if an infinite product ∏ β A β is a finite object, then all of A β are finite objects and all but a finite number of them are isomorphic to the terminal object 1 . Notice that the later condition is consistent with the way we defined C S f i n . Curiously, the state category 2-functor seems to be a "commutative" [9] 2-monad. Indeed, the 2-monad multiplication corresponds to the functor P : ( C S ) S → C S defined as follows. Given A an object of ( C S ) S : S ( P ( A ) ) : = ⊔ x ∈ S ( A ) S ( V A ( x ) ) V P ( A ) ( x , y ) : = V V A ( x ) ( y ) The 2-monoidal structure corresponds to the functor ν : C S × D S → ( C × D ) S defined as follows. Given A and object of C S and B an object of D : S ( ν ( A , B ) ) : = S ( A ) × S ( B ) V ν ( A , B ) ( x , y ) : = V A ( x ) × V B ( y ) This means that transducers are 1-morphisms in the corresponding Kleisli 2-category. In particular, composition of two transducers is a transducer. Moreover, an automaton is just a transducer from C to the terminal closed cartesian category. And, transducer string diagrams are essentially just string diagrams in the Kleisli 2-category. We can use the same methods to talk about arbitrary describable facts, but I'm content with computable. ↩︎ The analogy is very rough, it is possible that there is some stronger compositional language that contains both as segments. ↩︎ This is obvious, but I haven't seen it in the literature. ↩︎ I don't know whether even this special case is already known under some other name in automata theory. ↩︎ I don't know whether there is a standard name for this in category theory. ↩︎ ↩︎ In full generality, I'm not sure the composition of transducers yields transducers (however, it certainly does for closed cartesian automata, see below), so this language might define a broader class of "automata" rather than just describing them. ↩︎ Instead of S e t , we can use a different cartesian category for the state spaces of our automata, e.g. compact Polish spaces. But, we will continue the explanation using S e t , for the sake of simplicity. ↩︎ Equivalently, M 0 ( X ) is the free magma on X . In fact, algebras over M 0 are precisely magmas. ↩︎ Not sure what is the right term for 2-monads. ↩︎