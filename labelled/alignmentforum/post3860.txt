In the Logical Induction paper, we give a definition of logical inductors over polynomial time traders. It is clear from our definition that our use of polynomial time is rather arbitrary, and we could define e.g. an exponential time logical inductor. However, it may be less clear that actually logical inductors over one complexity class contain logical inductors over other complexity classes within them. For this post, I will define polynomial logical inductor to be the logical inductors defined in the main paper. I will define exponential logical inductor similarly, except the traders will be allowed to run in exponential time instead of polynomial time. Theorem: If { P n } is a polynomial logical inductor over { D n } , then the subsequence { P 2 2 n } is an exponential logical inductor over { D 2 2 n } . Proof Sketch: { P 2 2 n } is clearly computable. Assume by way of contradiction that { P 2 2 n } is not an exponential logical inductor over { D 2 2 n } . Then there exists some exponential time trading strategy which exploits it. This trader runs in time at most c ⋅ 2 n c for some c . But then there exists another trader which runs in polynomial time, and on input 2 2 n implements this trader against { P n } , and output's the constant 0 trading strategy otherwise. This can be done in polynomial time, since there is a polynomial of 2 2 n much larger than c ⋅ 2 n c . Note that this trader exploits { P n } , contradicting the assumption that { P n } is a polynomial logical inductor over { D n } . Clearly, this generalizes to other pairs of complexity classes as well. Observe that the converse is not necessarily true. In particular { P n } may not even converge when { P 2 2 n } is an exponential logical inductor over { D 2 2 n } . However logical inductors trivially contain logical inductors over smaller complexity classes, since logical inductors are themselves logical inductors over all smaller complexity classes. Combining this insight with that of Universal Inductors , we can now define a singe universal inductor, and use it to get a logical inductor by conditioning on a theory, and also use it to get universal and logical inductors over larger complexity classes, by taking sparse subsequences.