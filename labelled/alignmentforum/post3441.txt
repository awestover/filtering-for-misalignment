Introduction: Because logical induction relies on the Brouwer fixed-point theorem, and reflective oracles rely on the Kakutani fixed-point theorem which Brouwer is a special case of, it's possible that logical induction could have been derived for the first time from reflective oracles. Attempting to do this in the most obvious way by having traders output a circuit that takes a binary-search approximation of the market as input doesn't produce any insights in particular. However, by attempting to redevelop the logical induction algorithm from scratch with the aid of a bounded reflective oracle, we arrive at a new way of looking at logical induction, with the following interesting features. 1: It collapses the distinction between the algorithm outputting the trading circuit, and the trading circuit itself. 2: All trades can be naturally interpreted as probability measures over bitstrings, with the reward given by a simple betting game, instead of shares that pay off if some boolean combination is true. However, the betting game doesn't incentivize true belief reporting, just moving the probability distribution of the market in the right direction. This turns out to be isomorphic to the original formulation of the value of a trade, subject to one extra restriction on worst-case trade value. 3: The market prices are also a probability measure over bitstrings/worlds, exactly like a universal inductor . 4: It does the reflective-solomonoff thing of "draw a turing machine with probability 2 − K-complexity , use it to predict future bits" First, notation will be established, and the algorithm will be discussed. Then the connection between OI-trader scoring and LI-trader scoring will be established, and questions of how many of the nice properties of LI carry over will be discussed. We will finish with basic discussion of what this result means, and then there will be an appendix which contains the definitions of auxiliary algorithms, and the next post will contain the proof that the algorithm is an Oracle Inductor. As a quick refresher, a bounded reflective oracle takes as input a query of the form ( A , p ) , and returns 1 if A has bounded runtime, and only makes oracle calls to algorithms with the same runtime bound, and outputs 1 with probability greater than p , and 0 if A has bounded runtime and only makes oracle calls to algorithms with the same runtime bound, and outputs 1 with probability less than p . If the probability of a 1 is exactly p , or if A exceeds runtime bounds, the oracle is allowed to randomize arbitrarily. Notation: { 0 , 1 } L and { 0 , 1 } ∗ are the sets of all bitstrings of length L , and the set of all finite bitstrings, respectively. Elements of these sets are denoted by x . λ refers to the empty string. B L is the set of all satisfiable booleans with all variables having an index ≤ L , and B is the set of all satisfiable booleans. B ∗ is the set of all booleans (including unsatisfiable ones), and B ∗ L is the set of all booleans with all variables having an index ≤ L . Elements of these sets are denoted by B . B ⊤ is the trivial boolean which is satisfied by all bitstrings. Note that a boolean B ∈ B L induces a function { 0 , 1 } L → { 0 , 1 } . f is a function N + → N + that is time-constructible, monotonically increasing, and f ( t ) > t . It will give the runtime bound for the traders. l is some function N + → N + upper-bounded by 2 f ( t ) , that is time-constructible, monotonically increasing, and l ( t ) > t . It gives the most distant bit the oracle inductor thinks about on turn t . d is the function N + → N + given by d ( t ) = l ( t ) + ⌈ log 2 l ( t ) ⌉ + 2 t + 7 , giving the number of iterations of binary-search deployed on turn t . δ is the function N + → [ 0 , 1 ] ∪ Q given by δ ( t ) = 2 − ( t + 3 ) . It gives the proportion of the inductor distribution that is made up by the uniform distribution, to ensure that all bitstrings have a probability high enough for binary-search to accurately approximate their probability. query ( A , p ) consults the bounded reflective oracle about whether A returns 1 with probability greater than p . flip ( p ) rounds p down to 1 if it is greater than 1 , and then flips a coin that returns 1 with probability p . In our model of computation, this operation takes unit time. The OI Algorithm: ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ Algorithm 1: OI(t), N + → Δ { 0 , 1 } l(t) – –––––––––––––––––––––––––––––––––––––––– – IF flip( δ (t)) = 1 return Unif(l(t)) ELSE a ← Unif(f(t)) b ← 1 FOR i from 1 to f(t) IF flip ( 1 2 ) = 0 break ELSE b ← b + 1 return Approx(OI(t),l(t),d(t),BTtoBool(a,t,b)) In short, the distribution induced by the oracle induction algorithm has a small portion of the probability mass composed of the uniform distribution, and otherwise the algorithm selects a turing machine according to the universal distribution, and a "budget", with 2 − b of the probability mass on a budget of b , much like the logical inductor algorithm. In this setting, all trades can be interpreted as a mixture of probability distributions of the form "condition the oracle induction distribution on some boolean being true", so the budgeted trader is consulted to get a boolean (note that the trader may be randomized!), and Approx is used to approximately replicate the probability distribution produced by conditioning the oracle induction distribution on the resulting boolean. ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ Algorithm 2: Approx( Δ ,L,D,B), Δ { 0 , 1 } L × ( N + ) 2 × B L → Δ { 0 , 1 } L – –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– – x ← λ FOR i from 1 to L x ← x + NextBit( Δ ,D, i ,B, x ) return x This starts with the empty bitstring and repeatedly concantates it with NextBit which gets the next bit, until a bitstring of length L is produced. Δ , D and B are just passed on to NextBit . ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ Algorithm 3: NextBit( Δ ,D,i,B,x), Δ { 0 , 1 } L × ( N + ) 2 × B L × { 0 , 1 } i − 1 → Δ { 0 , 1 } – –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– – B ′ ← ToPref(x) ∧ B B ′ 0 ← B ′ ∧ ¬ x i B ′ 1 ← B ′ ∧ x i IF SAT ( B ′ 0 ) = 0 return 1 ELSE IF SAT ( B ′ 1 ) = 0 return 0 ELSE return flip ( BinSearch( 1 , eval ( B ′ 1 , Δ ) ,D) BinSearch( 1 , eval ( B ′ , Δ ) ,D) ) This defines a boolean constraint that says that B must be true, and the initial prefix of the bitstring must equal x . Then two more boolean constraints are generated, which are the same except they specify that the next bit is a 0 or 1 . If only one of the two is a satisfiable boolean, the next bit is forced to be 0 or 1 in compliance with the satisfiability requirement, otherwise, binary search for D iterations on the probability of Δ outputting a bitstring that satisfies B ′ or B ′ 1 is used to figure out the probability of the next bit being a 1 . ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ Algorithm 4: BinSearch(n, Δ ,D), { 0 , 1 , 2 } × Δ { 0 , 1 } × N + → [ 0 , 1 ] ∪ Q – –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– – h i ← 1 l o ← 0 FOR i from 1 to D IF query ( Δ , h i + l o 2 ) = 1 l o ← h i + l o 2 ELSE h i ← h i + l o 2 IF n = 0 return l o ELSE IF n = 1 return h i + l o 2 ELSE return h i This uses the oracle to implement binary-search for D rounds on some algorithm, and output either a lower-bound, average, or upper-bound estimate of the probability of the algorithm outputting 1 . ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ Algorithm 5: BTtoBool(a,t,b), { 0 , 1 } f ( t ) × ( N + ) 2 → B l ( t ) – –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– – IF query(OverBudget(a,t,b), 2 − l(t − 1 ) 2 ( t − 1 ) ) = 1 return B ⊤ ELSE return TradeToBool(a,t) This uses the oracle to test whether the trader is possibly over-budget, and if so, returns the null boolean, otherwise, it returns the boolean that the trader returns. OverBudget randomly selects a day and a world/bitstring, and returns 1 if the world/bitstring hasn't been ruled out by that day and the trader is over-budget relative to that world/bitstring, so the oracle call is testing whether there's any combination of worlds and days where the trader is over-budget. ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ Algorithm 6: OverBudget(a,t,b), { 0 , 1 } ∗ × ( N + ) 2 → Δ { 0 , 1 } – ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– – n ← rand( 1 , t − 1 ) B ← ToPref(Unif(l ( n ) )) IF SAT(DP( n ) ∧ B ) = 0 return 0 ELSE IF − n + ∑ 1 ≤ i ≤ n BinSearch( 0 , eval(clip( B , l(i)),Approx(OI(i),l(i),d(t),TradeToBool(a,i))),d(t)) BinSearch( 2 , eval(clip( B , l(i)),OI(i)),d(t)) < − b + 1 return 1 ELSE return 0 This randomly picks a day and bitstring, and returns 1 if the bitstring is plausible (hasn't been ruled out by the deductive process) on that day, and the trader might be over-budget. Note that the strength of the approximation rises as a function of t . This means that at later days, more accurate retroactive estimates are used for the value of a trade on previous days. The mess of parentheses in the numerator essentially clips the bitstring to the appropriate length, and uses binary search to find the probability that (an approximation of (the distribution produced by conditioning the OI distribution on (the boolean outputted by the trader))) assigns to the bitstring. ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ Algorithm 7: TradeToBool(a,i), { 0 , 1 } ∗ × N + → Δ B l ( i ) – ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– – run (a,i) on a UTM IF UTM(a,i) doesn't halt in f(i) steps, or an oracle call to an algorithm other than eval(B,OI(i')) for i' ≤ i, B ∈ B ∗ l ( i ) , is made, return B ⊤ ELSE B ← clip(ToBool(UTM(a,i)),l(i)) IF SAT( B ) = 0 return B ⊤ ELSE return B This takes a trader, and returns the null constraint if it times out or makes an "out of bounds" oracle call or outputs an unsatisfiable boolean. Otherwise, it takes the bitstring the trader outputs, interprets it as some boolean constraint, clips the constraint to the appropriate length, and outputs that constraint. Note that because algorithms can be randomized, this won't necessarily output the same boolean every time, so the distribution produced by Approx( Δ ,L,D,TradeToBool(a,i)) should actually be thought of as a probabilistic mixture of conditional distributions. To put all this together, the inductor selects a turing machine and a budget with the appropriate probability, and queries the turing machine about what boolean combination it thinks the true sequence of bits fulfills. As the turing machine can only report one boolean combination, mixtures of various booleans are implemented by the turing machine randomizing. If the past history of the turing machine has it possibly going over-budget on the next "trade", or violates conditions by running over time, or making illegal oracle calls, or providing an impossible-to-fulfill boolean, then the market just defaults to asking (an approximation of) itself about its own probabilities. Otherwise, the market outputs (an approximation of) its own probability distribution, conditioned on being in conformance with the trader. A bounded reflective oracle is exploited as an NP-oracle, and to effectively narrow down the probability of itself outputting a specific bitstring. Interpretation of a Trade: The interpretation of a trade from the logical induction paper was that you'd lose P ( x i ) dollars in order to acquire a share that would be worth 1 dollar in worlds x where x i = 1 ,and 0 dollars if x i = 0 . The interpretation of a trade in this setting is that a trader and a market spread 1 dollar amongst various bitstrings/worlds x ,(which will be lost), giving a probability measure, and if the world is revealed to be x , the trader earns T ( x ) P ( x ) dollars in return. (where T ( x ) is the probability the trader assigned to x , and P ( x ) is the probability the market assigned to x ). The value of a trader at time t in world x is then − t + ∑ 1 ≤ i ≤ t T i ( x ) P i ( x ) . Surprisingly enough, these two interpretations are actually equivalent! We can take (some) LI trades, and convert them into an OI trade with the same value in all worlds, and also do the reverse. First, let's say our OI trader spreads its dollar according to P | B (it copies the market probability distribution, conditional on the world fulfilling the constraint B ). Then, in all  worlds x that don't fulfill the boolean, it will lose 1 dollar because it assigned 0 measure to x , and in all x that fulfill the boolean, because T ( x ) = P ( x ) P ( B ) , it gets − 1 + 1 P ( B ) dollars in return. If we multiply these two values by P ( B ) , we get − P ( B ) dollars when it fails, and 1 − P ( B ) dollars when it succeeds, which is the exact same as a logical-induction trader buying one share in B . So, the value of the OI trader outputting the distribution P | B has the exact same value in all worlds as buying 1 P ( B ) shares of B , which is the same as spending 1 dollar buying shares of B . We interpret a randomized choice of a boolean as the trader T spending P ( T = B ) ( P is an ordinary probability, not the market price of anything)of the probability mass on the conditional distribution P | B . This sums up to produce a probability measure, where T ( x ) = ∑ B ∈ B P ( T = B ) ⋅ ( P | B ) ( x ) . Generalizing a bit, all OI trades are equivalent to a LI trade where it spends T ( x ) dollars buying shares of the boolean corresponding to x , and spends 1 dollar in total. Also, if the trader outputs the null boolean, T ( x ) = P ( x ) , so the value of that trade in all worlds is 0 and equivalent to not buying or selling anything. This can be used to have the equivalent LI trade spend less than 1 dollar buying shares, if some portion of T is composed of P . Going in the reverse direction, from a LI trade to a OI trade, is more difficult, because there is both buying and selling of shares. From before, buying 1 share of B is equivalent to the OI trader distributing P ( B ) of its probability mass according to the P | B distribution. It's slightly more involved to show, but selling 1 share of B has equivalent value in all worlds as distributing P ( ¬ B ) of the OI trader mass on the P | ¬ B distribution. Now, if, at the end of translating the LI trade into OI terms, less than all of the probability mass has been spent on various conditional distributions, the rest of the probability mass can be spent on copying P since it has 0 value in all worlds. But what if the measure of the resulting trade sums to greater than 1 ? In that case, the extreme-worst-case value of the LI trade (all purchased shares were worth 0 , all sold shares were worth 1 )is below − 1 . Therefore, if there's a LI trader with a circuit that's evaluatable in polynomial time (not just writable in poly-time), and it never makes a trade with extreme worst-case value below − 1 (ie, it doesn't blow too much money at any given time), there's a corresponding OI trader! This includes almost all the traders from the proofs of the logical induction paper. However, the traders from 4.7.2 (conditionals on theories) and 4.5.10 (affine unbiasedness from feedback) need to be adapted. Conjecture 1: There is an LI trader with extreme-worst-case value on each turn of − 1 that exploits the market if it violates Affine Unbiasedness from Feedback, and another such trader that exploits the market if the market conditional on ψ is exploitable by a trader with extreme-worst-case value on each turn of − 1 . If this conjecture holds, oracle induction would inherit all the nice properties of logical induction. Exploitation is defined in the standard way, as the set of plausible values according to worlds consistent with the deductive process at time t , over all t , being bounded below and unbounded above. Note that if we consider the market as composed of all the traders probability-distributions aggregated together, the payoff to everybody corresponds to taking everyone's money, and distributing that money back to everyone according to the fraction of the probability-mass in the winning world x that was contributed from their distribution. Also note that because the OI-traders can implement very long and complex combinations of distributions by randomizing, OI-traders are able to make some trades that LI-traders can't, because they can output trades that are too long and complicated for the LI-trader to write down in polynomial time. An OI-trader, converted to an LI-trade, may even have purchases in every single boolean, which LI-traders definitely can't replicate. Conjecture 2: There is an LI trader that runs in poly-time, and an Oracle Inductor that is inexploitable by poly-time adversaries, such that the trader exploits the Oracle Inductor, and there is an OI trader that runs in poly-time and a Logical Inductor that is inexploitable by poly-time adversaries, such that the trader exploits the Logical Inductor. Facts About OI: Just like logical inductors, there is no trader that runs in time less than f ( t ) that exploits the market. This is shown by the following theorems which are analogous to the theorems establishing that the logical induction algorithm is inexploitable. Theorem 1: If a trader that can be simulated on a UTM in less than f ( t ) time exploits OI , there is some finite budget b such that the budgeted trader exploits OI . Theorem 2: If a budgeted trader exploits OI , the supertrader exploits OI . Theorem 3: The supertrader doesn't exploit OI . The proofs will be deferred to the next post. As for the strength of the bounded reflective oracle needed to guarantee that all oracle calls are well-defined, it is O ( l ( t ) 3 + t 3 l ( t ) 2 + l ( t ) f ( t ) + f ( t ) log f ( t ) ) . Again, the proof will be deferred to the next post. Future Directions: The two conjectures would be interesting to settle, although only the first is truly critical to showing that this is as powerful as a logical inductor. The interpretation of trades as probability measures over bitstrings, with payoff given by the proportion of probability mass in the winning string contributed by a trader is useful, although the lack of an incentive for accurate belief reporting is slightly worrying, and prevents us from truly attributing beliefs to individual traders. The close parallel between this and Reflective-Oracle Solomonoff Induction may prove to be fruitful, and potentially lead to a variant of AIXI in this setting, which may be ported back to logical induction. APPENDIX: Auxiliary Algorithms ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ flip(p), Q ≥ 0 → Δ { 0 , 1 } – –––––––––––––––––––––––– – p ← min( 1 , p ) return output of a coin which returns 1 with probability p In our model of computation, assume that this takes unit time. ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ Unif(n), N → Δ { 0 , 1 } n – ––––––––––––––––––––––– – x ← λ FOR i from 1 to n x ← x + flip ( 1 2 ) return x This generates a random bitstring of length n . ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ rand(m,n), ( N + ) 2 → Δ N + – ––––––––––––––––––––––––––– – FOR i from m to n IF flip( 1 n − i + 1 ) = 1 return i break This randomly selects an integer in [ m , n ] , with equal probability for each integer. ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ clip(B,n), B ∗ × N + → B ∗ – ––––––––––––––––––––––––– – B ← B with all variables with an index >n removed return B This is used to ensure that the traders output boolean constraints that aren't about unreasonably distant digits. ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ eval(B,x), B ∗ × { 0 , 1 } ∗ → Δ { 0 , 1 } – ––––––––––––––––––––––––––––––––––– – n ← max index of a variable in B x ← x+Unif(max(0, n -|x|)) return B( x ) This applies a boolean circuit to a bitstring, and pads it with randomly selected bits if the bitstring is too short. Note that since traders are allowed to call the oracle on this function applied to the oracle inductor, this implicitly assigns 50% probability to all bits that are too distant for the oracle inductor to have thought about them yet. ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ ToPref(x), { 0 , 1 } ∗ → B – –––––––––––––––––––––––– – B ← ⋀ 1 ≤ i ≤ |x| y i = x i return B This converts a bitstring to a boolean which requires that the prefix of a bitstring equals x . The equality should be understood as ¬ y i if x i = 0 , and y i if x i = 1 . ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ SAT(B), B ∗ → { 0 , 1 } – –––––––––––––––––––––– – n ← max index of a variable in B return query(eval(B, λ ) , 2 − ( n + 1 ) ) This uses the oracle as a SAT-solver, by using eval(B, λ ) to randomly generate a bitstring of length n . If there is a bitstring which fulfills the boolean, there is a 2 − n probability of generating that bitstring, so the oracle can perfectly discriminate between satisfiable and unsatisfiable booleans. ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ ToBool(x), { 0 , 1 } ∗ → B ∗ – ––––––––––––––––––––––––– – This just turns a bitstring into the boolean it encodes, given some efficient encoding scheme. ¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯ DP(n), N + → B l ( n ) – ––––––––––––––––––– – This is the deductive process, a blackbox deterministic algorithm which outputs booleans of index at most l ( n ) in at most max ( l ( n ) , f ( n ) ) time s.t ∀ n ∀ i < n : D P ( n ) ∧ D P ( i ) = D P ( n ) (ie, the constraints on the true environment get more stringent over time but always stay satisfiable).